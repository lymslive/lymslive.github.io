<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1" name="viewport" />
  <meta content="#ffffff" name="theme-color" />
  <meta content="#da532c" name="msapplication-TileColor" />

  
  
  
  
  

  

  

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1.9.1/css/academicons.min.css" integrity="sha384-FIue+PI4SsI9XfHCz8dBLg33b0c1fMJgNU3X//L26FYbGnlSEfWmNT7zgWc2N9b6" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link href="https://lymslive.github.io/deep-thought.css" rel="stylesheet" />
  
<link href="/page-patch.css" rel="stylesheet" />


  <title>
    
沉思涧 | make 不干编译事的清奇妙用：子命令模式脚本

  </title>

  
  
  

  
</head>

<body class="has-background-white">
  <nav aria-label="section navigation" class="navbar is-light" role="navigation">
    <div class="container">
      <div class="navbar-brand">
        <a class="navbar-item is-size-5 has-text-weight-bold" href="https:&#x2F;&#x2F;lymslive.github.io">沉思涧</a>
        <a aria-expanded="false" aria-label="menu" class="navbar-burger burger" data-target="navMenu" role="button">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
      </div>
      <div class="navbar-menu" id="navMenu">
        <div class="navbar-end has-text-centered">
          
          
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;lymslive.github.io&#x2F;">
            首页
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;lymslive.github.io&#x2F;blog">
            博客
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;lymslive.github.io&#x2F;book">
            书册
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;lymslive.github.io&#x2F;think">
            文思
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;lymslive.github.io&#x2F;white">
            白学
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;lymslive.github.io&#x2F;tags">
            标签
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;lymslive.github.io&#x2F;categories">
            归类
          </a>
          
          
          
          <a class="navbar-item" id="nav-search" title="Search" data-target="#search-modal">
            <span class="icon">
              <i class="fas fa-search"></i>
            </span>
          </a>
          <a class="navbar-item" id="dark-mode" title="Switch to dark theme">
            <span class="icon">
              <i class="fas fa-adjust"></i>
            </span>
          </a>
        </div>
      </div>
    </div>
  </nav>

  
  

  
<section class="section">
  <div class="container">
    <div class="columns">
      <div class="column is-8 is-offset-2">
        <article class="box">
          <h1 class="title">
            make 不干编译事的清奇妙用：子命令模式脚本
          </h1>
          <p class="subtitle"></p>
          <div class="columns is-multiline is-gapless">
            <div class="column is-8">
              
<span class="icon-text has-text-grey">
  <span class="icon">
    <i class="fas fa-user"></i>
  </span>
  <span>七阶子</span>
  <span class="icon">
    <i class="far fa-calendar-alt"></i>
  </span>
  <span><time datetime="2023-12-26">2023-12-26</time></span>
</span>

            </div>
            <div class="column is-4 has-text-right-desktop">
              
<span class="icon-text has-text-grey">
  <span class="icon">
    <i class="far fa-clock"></i>
  </span>
  <span>48 min,</span>
  <span class="icon">
    <i class="fas fa-pencil-alt"></i>
  </span>
  <span>9596 words</span>
</span>

            </div>
            <div class="column">
              
              
<p>
  归类：
  
  <a class="has-text-info-dark has-text-weight-semibold" href="https://lymslive.github.io/categories/gong-ju-shi-yong/">
    <span class="icon-text">
      <span class="icon">
        <i class="fas fa-cube"></i>
      </span>
      <span>工具使用</span>
    </span>
  </a>
  
</p>

              
            </div>
            <div class="column has-text-right-desktop">
              
              
<p>
  标签：
  
  <a class="has-text-info-dark has-text-weight-semibold" href="https://lymslive.github.io/tags/linux/">
    <span class="icon-text">
      <span class="icon">
        <i class="fas fa-tag"></i>
      </span>
      <span>linux</span>
    </span>
  </a>
  
  <a class="has-text-info-dark has-text-weight-semibold" href="https://lymslive.github.io/tags/make/">
    <span class="icon-text">
      <span class="icon">
        <i class="fas fa-tag"></i>
      </span>
      <span>make</span>
    </span>
  </a>
  
  <a class="has-text-info-dark has-text-weight-semibold" href="https://lymslive.github.io/tags/bash/">
    <span class="icon-text">
      <span class="icon">
        <i class="fas fa-tag"></i>
      </span>
      <span>bash</span>
    </span>
  </a>
  
</p>

              
            </div>
          </div>
          <div class="content mt-2" id="article-content">
            <h2 id="yin-yan">引言</h2>
<p>说起 make ，大家的印象想必都是 Linux 下用于编译构建 C/C++ 项目的原始工具。后来
随着 cmake 及其他多种构建工具的发展与流行，手搓 makefile 的情况应该越来越少
了。而且除了 cmake ，有些构建工具是根本不必生成 makefile 就直接自己处理依赖编
译项目了，这比借助 makefile 路径依赖还更高效些。于是 make 在构建系统的作用与地
位就逐渐淡出了。</p>
<p>不过再追溯一下 make 本源，它似乎并不是专为编译构建而诞生的。早期 Linux 的许多
经典工具都只有简单到令人吃惊的小功能，贯彻着“一个程序只做好一件事”的哲学思想。
所以 make 的核心功能也非常简单，就只是检测目标与依赖（文件）的关系，当依赖有更
新时，执行相应的命令让目标也得以更新。而这个功能，明面上完全看不出来它与用 gcc
编译 C/C++ 项目有什么必然联系。只过在 Linux 上工作的程序员先驱们，竟然能在这么
简单的 make 基础上，发展出完备而复杂的构建系统，也是令我们后学惊叹的。</p>
<p>所以我有时在想，在如今不一定需要用 make 来构建 C/C++ 项目的时代，利用 make 的
核心功能与思想，还能否玩出其他有趣的花样？本文就介绍笔者在实际工作中遇到的一个
常用场景，利用 make 来组织一堆简单小脚本，提供统一命令行用法，让 make 命令华丽
转身，活像个能带自定义子命令的命令行工具。而子命令模式，正是当前流行的命令行工
作方式，像 git docker systemctl 等强大的流行工具就是子命令模式。</p>
<span id="continue-reading"></span><h2 id="yong-make-zu-zhi-zi-ming-ling-jiao-ben">用 make 组织子命令脚本</h2>
<h3 id="dian-xing-kai-fa-chang-jing-de-ri-chang-ren-wu">典型开发场景的日常任务</h3>
<p>先假设一个应该很常见的 Linux 开发场景。在开发一个 C++ 项目，也许是不大不小的微
服务。修改一部分代码后，首先要编译通过，至少保证没有语法错误，总不能依靠现代编
辑器的智能提示说它正确就信了。然后，抛开单元测试不谈，可能也要求在本地试下启动
能跑起来，尤其是涉及动态链接库的程序，能编译链接成功还不一定能保证能成功加载，
得在启动时才能报找不到符号之类的错误。也许 debug 版本就在本地跑个服务了，与其
他同事的服务联调。等差不多了，才打包部署到其他专门的机器上统一测试。</p>
<p>乍听起来，这好像是持续集成与部署（CICD）的事儿。但 CICD 系统一般是从 git 仓库
上拉代码下来再进行后续的一键编译部署吧，而新鲜出撸的代码没经过基本的验证就能提
交 git 的吗？这里主要想说的是，AI 取代程序猿开发的梦想仍然很远，我们在日常开发
中仍然有很多重复、琐碎的任务要做。这些任务或许只是敲一条或几条 bash 命令的事，
如果总是涉及多条命令，封装为一个简短的 bash 脚本是个好主意。所以，总结一下典型
开发场景，可能涉及如下一些日常任务，并且暂用 bash 脚本补充命名：</p>
<ul>
<li>编译：build.sh</li>
<li>启动：start.sh</li>
<li>停止：stop.sh</li>
<li>重启：restart.sh</li>
<li>查看日志：lastlog.sh</li>
<li>……</li>
</ul>
<h3 id="makefile-tong-yi-guan-li">Makefile 统一管理</h3>
<p>为每个任务写几行小脚本，是个可行方案，但也有些不足问题。比如这些小脚本放哪就是
个事。太多小脚本放项目根目录总归不好，单独放在 <code>script/</code> 子目录会好些，只是调
用时要多敲些字符。然后可用一个 makefile 来管理这些小脚本，最简单的示例如下：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">.PHONY</span><span>: </span><span style="color:#a3be8c;">build start stop restart log
</span><span>
</span><span style="color:#8fa1b3;">build</span><span>:
</span><span>    </span><span style="color:#bf616a;">script/build.sh
</span><span>
</span><span style="color:#8fa1b3;">start</span><span>:
</span><span>    </span><span style="color:#bf616a;">script/start.sh
</span><span>
</span><span style="color:#8fa1b3;">stop</span><span>:
</span><span>    </span><span style="color:#bf616a;">script/stop.sh
</span><span>
</span><span style="color:#8fa1b3;">restart</span><span>:
</span><span>    </span><span style="color:#bf616a;">script/restart.sh
</span><span>
</span><span style="color:#8fa1b3;">log</span><span>:
</span><span>    </span><span style="color:#bf616a;">script/lastlog.sh
</span></code></pre>
<p>将每种任务当作目标，不写依赖，那 make 它时必然会调用下面的命令。<code>.PHONY</code> 的作
用是声明伪目标，这样 <code>make build</code> 时，就不会检查是否存在名叫 <code>build</code> 的文件或
目录，直接调用命令。如果 <code>build</code> 不是伪目标，当 make 发现存在这个文件或目录时，
就认为该目标是最新的，不会执行命令。</p>
<p>在很多情况下，重启的操作，应该就是简单的先停止，再启动。那么 <code>restart</code> 目标在
makefile 可以改写如下，明确这种顺序“依赖”关系，不需单独的脚本：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">restart</span><span>: </span><span style="color:#a3be8c;">stop start
</span></code></pre>
<p>还可以根据需要串联更多的动作。比如，在改过一些代码后，希望编译、重启、查看日志
一键完成，那么可以加个目标，<code>all</code> 也许就合适，改动如下：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">.PHONY</span><span>: </span><span style="color:#a3be8c;">all build start stop restart log
</span><span>
</span><span style="color:#8fa1b3;">all</span><span>: </span><span style="color:#a3be8c;">build restart log
</span><span>
</span><span style="color:#8fa1b3;">build</span><span>:
</span><span>    </span><span style="color:#bf616a;">script/build.sh
</span><span>
</span><span style="color:#8fa1b3;">start</span><span>:
</span><span>    </span><span style="color:#bf616a;">script/start.sh
</span><span>
</span><span style="color:#8fa1b3;">stop</span><span>:
</span><span>    </span><span style="color:#d08770;">- </span><span style="color:#bf616a;">script/stop.sh
</span><span>
</span><span style="color:#8fa1b3;">restart</span><span>: </span><span style="color:#a3be8c;">stop start
</span><span>
</span><span style="color:#8fa1b3;">log</span><span>:
</span><span>    </span><span style="color:#bf616a;">script/lastlog.sh
</span></code></pre>
<p>现在 <code>all</code> 目标写在最前面了，所以在无参数执行 <code>make</code> 就会默认执行第一个目标，
即等效于 <code>make all</code> 。另外，<code>stop</code> 目标的命令前加了一个短横 <code>-</code> ，它表示允许失
败的意思。即假如服务不在运行时，执行 <code>stop.sh</code> 脚本可能是非 0 退出，当然也可以
把 <code>stop.sh</code> 写得更优雅点，没什么可停止时也能正常退出。</p>
<h3 id="bang-zhu-xin-xi-make-help">帮助信息 make help</h3>
<p>最后，还可以为这组 makefile 脚本加个帮助说明，并且在空参数 <code>make</code> 不默认执行
<code>make all</code> ，而是 <code>make help</code> 打印说明，则可以加个 <code>help</code> 目标：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">.PHONY</span><span>: </span><span style="color:#a3be8c;">help all build start stop restart log
</span><span>
</span><span style="color:#8fa1b3;">help</span><span>:
</span><span style="color:#8fa1b3;">all</span><span>: </span><span style="color:#a3be8c;">build restart log
</span><span>
</span><span style="color:#65737e;"># ...
</span><span>
</span><span style="color:#8fa1b3;">help</span><span>:
</span><span>    </span><span style="color:#d08770;">@</span><span style="color:#96b5b4;">echo</span><span> make build: 编译项目
</span><span>    </span><span style="color:#d08770;">@</span><span style="color:#96b5b4;">echo</span><span> make start: 启动服务
</span><span>    </span><span style="color:#d08770;">@</span><span style="color:#96b5b4;">echo</span><span> make stop:  停止服务
</span><span>    </span><span style="color:#d08770;">@</span><span style="color:#96b5b4;">echo</span><span> make restart: 重启服务
</span><span>    </span><span style="color:#d08770;">@</span><span style="color:#96b5b4;">echo</span><span> make log: 查看最近的日志
</span><span>    </span><span style="color:#d08770;">@</span><span style="color:#96b5b4;">echo</span><span> make all: 一键编译、重启、查看日志
</span><span>    </span><span style="color:#d08770;">@</span><span style="color:#96b5b4;">echo</span><span> make help: 打印这些帮助信息
</span></code></pre>
<p>打印帮助的命令可以写在文件最后，但若要成为默认目标，需要在前面添加一行 <code>help:</code>
不带命令块，相当于提前声明，后面再定义。当然也可以直接将定义写在最前面，看个人
喜好。<code>@echo ...</code> 命令前面加 <code>@</code> 前缀是表示不回显命令本身。对比常规的目标命令，
比如 <code>make build</code> ，会在终端打印它执行的命令即 <code>script/build.sh</code> ，但 <code>echo</code>
命令，没必要把自己多打印一次，只打印 <code>echo</code> 的结果（即其后参数）即可。</p>
<h2 id="zi-ming-ling-jiao-ben-you-hua-tan-tao">子命令脚本优化探讨</h2>
<p>用上 make 统一管理后，再回头审视一下各个任务（子命令）脚本的编写，或可作些优化。</p>
<h3 id="gou-jian-make-build">构建 make build</h3>
<p>先看构建目标 <code>build</code> ，如果项目源代码是用 cmake 工具链编译的，那其实就典型的几
句话，或可不必额外写 <code>build.sh</code> 了：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">build</span><span>:
</span><span>    </span><span style="color:#d08770;">@</span><span style="color:#bf616a;">mkdir -p</span><span> build
</span><span>    </span><span style="color:#96b5b4;">cd</span><span> build
</span><span>    </span><span style="color:#bf616a;">cmake</span><span> ..
</span><span>    </span><span style="color:#bf616a;">make
</span><span>    </span><span style="color:#bf616a;">make</span><span> install
</span></code></pre>
<p>如果也就用 make 编译，那更简单，不过并不适合直接放在根目录下的这个主控 makefile 。
假如在 <code>src/</code> 子目录有专门一个 makefile 来编译，则可写成：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">build</span><span>:
</span><span>    </span><span style="color:#bf616a;">make -C</span><span> src
</span></code></pre>
<p>如果编译的 makefile 也想放在根目录，那要改个文件名，比如叫 <code>build.mk</code> ，则写成：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">build</span><span>:
</span><span>    </span><span style="color:#bf616a;">make -f</span><span> build.mk
</span></code></pre>
<p>选项 <code>-f</code> 指定读取的 makefile 文件，默认就是名字为 <code>makefile</code> 或 <code>Makefile</code> 的
那个。<code>-C</code> 是切换当前工作目录，再解析 makefile，当前工作目录对解析相对路径有影
响。</p>
<h3 id="yun-xing-make-start-stop">运行 make start stop</h3>
<p>假如在构建阶段，将可执程序放到了 <code>bin/</code> 子目录下，那么 <code>start</code> 目标也不外是执
行这个程序，当然，服务程序可能要用 <code>nohup</code> 在后台启动：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#bf616a;">SERVER_NAME</span><span>=</span><span style="color:#a3be8c;">my-program
</span><span style="color:#8fa1b3;">start</span><span>:
</span><span>    </span><span style="color:#bf616a;">nohup</span><span> bin/</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SERVER_NAME</span><span style="color:#b48ead;">) </span><span>&amp;
</span></code></pre>
<p>这里还为服务名定义一个变量，以便能多处复用。</p>
<p>如果服务依赖的一些动态链接库（自己项目内编译的或第三方的）放在了 <code>lib/</code> 子目录，
则还要添加 <code>LD_LIBRARY_PATH</code> 。为当前命令添加环境变量可以这么写：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">start</span><span>:
</span><span>    </span><span style="color:#bf616a;">LD_LIBRARY_PATH</span><span>=</span><span style="color:#a3be8c;">./lib </span><span style="color:#bf616a;">nohup</span><span> bin/</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SERVER_NAME</span><span style="color:#b48ead;">) </span><span>&amp;
</span></code></pre>
<p>如果启动阶段还有其他较为复杂的定制步骤，就写在单独的 <code>script/strat.sh</code> 也好。</p>
<p>停止服务最简单粗暴的方法是 <code>kill</code> 大法，虽不推荐但可作为示例。如果服务启动会写
个 pid 文件，可以这么写：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">stop</span><span>:
</span><span>    </span><span style="color:#96b5b4;">kill</span><span> -9 `</span><span style="color:#bf616a;">cat </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SERVER_NAME</span><span style="color:#b48ead;">)</span><span>.pid`
</span></code></pre>
<p>不写 pid 文件的话，可以借鉴手动 <code>ps | grep</code> 大法列出，再用 <code>sed</code> 或 <code>awk</code> 提取
pid 。这可能就有点丑陋与复杂了。</p>
<h3 id="shi-yong-systemd-guan-li-fu-wu-yun-xing">使用 systemd 管理服务运行</h3>
<p>事实上，我更推荐用 <code>systemd</code> 来管理服务的启动与停止等操作。这需要先配置
my-program.service 单元文件，这不是本文件的重点，但不妨先假设配好了，就可以用
<code>systemctl</code> 命令来管理服务了。那就可以改写 <code>start</code> 与 <code>stop</code> 目标的实现了，或
者若不想覆盖之前的，也可加点后缀另起个目标名字，如：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">start.sd</span><span>: 
</span><span>    </span><span style="color:#bf616a;">sudo</span><span> systemctl start </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SERVER_NAME</span><span style="color:#b48ead;">)
</span><span>
</span><span style="color:#8fa1b3;">stop.sd</span><span>: 
</span><span>    </span><span style="color:#bf616a;">sudo</span><span> systemctl stop </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SERVER_NAME</span><span style="color:#b48ead;">)
</span><span>
</span><span style="color:#8fa1b3;">status.sd</span><span>: 
</span><span>    </span><span style="color:#bf616a;">systemctl</span><span> status </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SERVER_NAME</span><span style="color:#b48ead;">)
</span><span>
</span><span style="color:#8fa1b3;">restart.sd</span><span>: 
</span><span>    </span><span style="color:#bf616a;">sudo</span><span> systemctl restart </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SERVER_NAME</span><span style="color:#b48ead;">)
</span></code></pre>
<p>以上，相当于用 <code>make start.sd</code> 来简化 <code>sudo systemctl start ...</code> 的命令行输入。
正常来说，<code>systemctl</code> 命令需要 root 权限，所以注意要加 <code>sudo</code> ，不过 <code>status</code>
命令可不用 <code>sudo</code> 毕竟是只读的。systemctl 也有 <code>restart</code> 子命令，但若没有特殊
配置，默认动作也就相当于先 stop 再 start 。</p>
<p>既然以上 <code>systemctl</code> 命令依赖配置文件 <code>/etc/systemd/system/my-program.service</code>，
那也可以将这依赖写在 <code>start.sd</code> 等目标之后，当第一次没配置就执行时肯定就会报错，
意味着提醒你该手动配置一次这个文件。再进一步，假设有许多微服务的 <code>.service</code> 配
置都长差不多，可以通过一个模板配置由简单脚本生成针对当前服务的配置。那就可以
把这些前置动作都写进 makefile 依赖：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#bf616a;">SYSTEMD_UNIT</span><span>=</span><span style="color:#a3be8c;">/etc/systemd/system/</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SERVER_NAME</span><span style="color:#b48ead;">)</span><span style="color:#a3be8c;">.service
</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SYSTEMD_UNIT</span><span style="color:#b48ead;">)</span><span>: </span><span style="color:#a3be8c;">script/systemd-service-generator.sh script/systemd-template.service
</span><span>    </span><span style="color:#bf616a;">script/systemd-service-generator.sh</span><span> script/systemd-template.service
</span><span style="color:#65737e;"># 假设脚本先将 .service 配置生成在当前目录，再开 sudo 移动到 /etc/...
</span><span>    sudo mv </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SERVER_NAME</span><span style="color:#b48ead;">)</span><span>.service </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SYSTEMD_UNIT</span><span style="color:#b48ead;">)
</span><span>    sudo systemctl daemon-reload
</span><span>
</span><span style="color:#8fa1b3;">start.sd</span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SYSTEMD_UNIT</span><span style="color:#b48ead;">)
</span><span>    </span><span style="color:#bf616a;">sudo</span><span> systemctl start </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SERVER_NAME</span><span style="color:#b48ead;">)
</span><span style="color:#8fa1b3;">stop.sd</span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SYSTEMD_UNIT</span><span style="color:#b48ead;">)
</span><span>    </span><span style="color:#bf616a;">sudo</span><span> systemctl stop </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SERVER_NAME</span><span style="color:#b48ead;">)
</span><span style="color:#65737e;"># ...
</span></code></pre>
<p>这样，假设后来若有需要优化 <code>.service</code> 配置，修改了生成脚本或模板，那也只要执行
<code>make restart.sd</code> ，它前面的依赖配置也会自动再生成更新。</p>
<h3 id="da-bao-ren-wu-make-tar">打包任务 make tar</h3>
<p>现在假设在开发本地自测验证过了，需要打个压缩包给出去。如果已经写过脚本来做这事，
那也只是在 makefile 中加一个目标的事：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">tar</span><span>:
</span><span>    </span><span style="color:#bf616a;">script/tar-pack.sh
</span></code></pre>
<p>或者在简单的情况下，根本用不着打包脚本，就一个 <code>tar</code> 命令行的事，也可写进
makefile 以便更简单地输入 <code>make tar</code>：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">tar</span><span>:
</span><span>    </span><span style="color:#bf616a;">tar</span><span> czvf </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SERVER_NAME</span><span style="color:#b48ead;">)</span><span>.tar.gz bin/ lib/
</span></code></pre>
<p>这里是简单假设打包 <code>bin/</code> 与 <code>lib/</code> 两个子目录。如果情况稍复杂点，比如还要打包
配置文件，或只要打包 <code>bin/</code> 或 <code>lib/</code> 下面部分文件，例如想排除单元测试程序……
如此，这个单行 <code>tar</code> 命令就会变得复杂起来，尤其是后面还改动时，单长行修改也对
<code>git diff</code> 不友好。</p>
<p>现在用 make 的思路来分析打包这个任务。将打包过程分成两个阶段会更清晰，先是将要
打包的各个文件拷到一个临时目录，再调用 <code>tar</code> 对这个临时目录整体打包。这就对应
着 make 的两个目标，写 makefile 时对目标顺序无关，故也可自底而上写，先写后一步
简单的：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">.PHONY</span><span>: </span><span style="color:#a3be8c;">tar
</span><span>
</span><span style="color:#bf616a;">TAR_DIR</span><span>=</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SERVER_NAME</span><span style="color:#b48ead;">)</span><span style="color:#a3be8c;">-release
</span><span style="color:#bf616a;">TAR_NAME</span><span>=</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SERVER_NAME</span><span style="color:#b48ead;">)</span><span style="color:#a3be8c;">-release.tar.gz
</span><span>
</span><span style="color:#8fa1b3;">tar</span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TAR_NAME</span><span style="color:#b48ead;">)
</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TAR_NAME</span><span style="color:#b48ead;">)</span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TAR_DIR</span><span style="color:#b48ead;">)
</span><span>    </span><span style="color:#bf616a;">tar</span><span> czvf </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TAR_NAME</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">TAR_DIR</span><span style="color:#b48ead;">)
</span></code></pre>
<p>以上，假设待打包的“临时”目录叫 <code>release</code> ，并且加上本服务名前缀，这是考虑将压
缩包拷出去后在别的机器上解压出来不能只叫光溜溜的 <code>release</code> 名字。伪目标 <code>tar</code>
依赖一个真实存在或将存在的压缩文件，而该压缩文件依赖一个目录，而这个目录应该依
赖待要拷入它的其他文件。据此可继续写 makefile 如下：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#65737e;"># 待打包文件
</span><span style="color:#bf616a;">FILE_LIST </span><span>= </span><span style="color:#a3be8c;">\
</span><span style="color:#a3be8c;">    bin/my-program \
</span><span style="color:#a3be8c;">    lib/libmyutil.so \
</span><span style="color:#a3be8c;">    conf/my-program.ini \
</span><span style="color:#a3be8c;">    makefile
</span><span>
</span><span style="color:#65737e;"># 各打包文件添加目录前缀 -release
</span><span style="color:#bf616a;">FILE_INTAR </span><span>= </span><span style="color:#b48ead;">$(</span><span style="color:#96b5b4;">patsubst </span><span style="color:#bf616a;">%</span><span style="color:#a3be8c;">,</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TAR_DIR</span><span style="color:#b48ead;">)</span><span style="color:#a3be8c;">/</span><span style="color:#bf616a;">%</span><span style="color:#a3be8c;">,</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">FILE_LIST</span><span style="color:#b48ead;">))
</span><span>
</span><span style="color:#65737e;"># 每个 -release 目录内文件，依赖上层目录的源文件，拷贝更新
</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">FILE_INTAR</span><span style="color:#b48ead;">)</span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TAR_DIR</span><span style="color:#b48ead;">)</span><span style="color:#a3be8c;">/</span><span style="color:#bf616a;">%</span><span style="color:#a3be8c;"> : </span><span style="color:#bf616a;">%
</span><span>    </span><span style="color:#bf616a;">cp $&lt; $@
</span><span>
</span><span style="color:#65737e;"># 整个待压缩目录依赖拷入的每个文件
</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TAR_DIR</span><span style="color:#b48ead;">)</span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">FILE_INTAR</span><span style="color:#b48ead;">)
</span></code></pre>
<p>以上，每行语句添加了注释。我将待打包的每个文件显式列出来，没有用变量替换（如之
前有定义 <code>SERVER_NAME=my-program</code>），是考虑那几行文件名可当作文件清单的文档
参考，真实项目这个清单可能会更长些。唯一不爽的是限于 makefile 语法，每行末尾要
有反斜杠续行。</p>
<p>其后就是 makefile 函数与语法的典型应用了。其中 <code>cp $&lt; $@</code> 那行命令，结构就很像
在写编译 C/C++ 项目的 makefile 时，将每个 <code>.cpp</code> 编译为相应的 <code>.o</code> 的命令，只
不过在那里用的是 <code>g++</code> 命令及一些复杂选项，这里只是简单的 <code>cp</code> 命令。将它展开，
就相当于如下几个目标与命令：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">my-program-release/bin/my-program </span><span>: </span><span style="color:#a3be8c;">bin/my-program
</span><span>    </span><span style="color:#bf616a;">cp</span><span> bin/my-program my-program-release/bin/my-program
</span><span style="color:#65737e;"># ...
</span><span style="color:#8fa1b3;">my-program-release/makefile </span><span>: </span><span style="color:#a3be8c;">makefile
</span><span>    </span><span style="color:#bf616a;">cp</span><span> makefile my-program-release/makefile
</span></code></pre>
<p>是的，这里将主控 makefile 文件也打包进去了。虽然解压后没源码用不了 <code>make build</code>
，但还可用 <code>make start</code> 与 <code>make stop</code> 之类的呀，后者才是本文所讲的 makefile
核心功能。</p>
<p>在常规的打包脚本中，打包压缩后可能会将拷贝收集用的临时目录删掉。在这里我却觉得
没必要将 <code>my-program-release</code> 目录删掉，在 makefile 的依赖链控制下，它里面的文
件是能同步更新的，故可留着作为参考。</p>
<p>另外提一点，这里没特别在意通过 <code>make build</code> 编译后放在 <code>bin/</code> 目录下的可执行程
序是 debug 版还是 release 版，就直接打包了。如有需要，额外建个 <code>build.rel</code> 目
标也可，这里不再详细展开了。</p>
<p>这几段打包的 makefile 语句，可能有点偏长了，但是打包也非使用最频繁的命令，放在
主控 makefile 文件中如果觉得有喧宾夺主之嫌，则可以单独移到一个文件，比如命名为
<code>tar.mk</code> ，然后在主控文件中只留下一个 <code>tar</code> 目标转调：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">tar</span><span>:
</span><span>    </span><span style="color:#bf616a;">make -f</span><span> tar.mk
</span></code></pre>
<h3 id="rong-qi-hua-ying-yong-ren-wu">容器化应用任务</h3>
<p>现在，假设要赶容器化的潮流，想把我们的服务程序也放在容器中去运行。容器运行的前
提是先要做个镜像。严肃点说，编译也该放到容器中去，更容易保证环境一致性。不过本
文为了故事的简单性，就仍用之前通过 <code>make build</code> 编译出的程序，打成镜像，也相当
于另一种方式的打包。</p>
<p>于是也就可再利用上节打包过程中建立的 <code>my-program-release/</code> 目录，这里收集了我
们程序运行所需的文件，拷进镜像就成了。也就说把这个目录当成 <code>docker build</code> 命令
的 context （路径参数），只把这个目录的内容发到 docker 引擎中作为构建镜像的原
料。这比把当前目录（整个项目根目录）发过去更高效，虽然也可以用 <code>.dockerignore</code>
忽略大量不必要文件（如 <code>src/</code> 与 <code>log/</code>），但仍不如搞一个清爽的目录。把这个目
录当成制作镜像的依赖，那就容易写出 makefile 了：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">IMAGE_TAG = </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SERVER_NAME</span><span style="color:#b48ead;">)</span><span>:</span><span style="color:#a3be8c;">latest
</span><span style="color:#8fa1b3;">image</span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TAR_DIR</span><span style="color:#b48ead;">)
</span><span>    </span><span style="color:#bf616a;">docker</span><span> build </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TAR_DIR</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;"> -t </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">IMAGE_TAG</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;"> -f</span><span> ./Dockerfile
</span></code></pre>
<p>而 Dockerfile 的内容也可以很简单，如：</p>
<pre data-lang="dockerfile" style="background-color:#2b303b;color:#c0c5ce;" class="language-dockerfile "><code class="language-dockerfile" data-lang="dockerfile"><span style="color:#b48ead;">FROM</span><span> contos:7
</span><span style="color:#b48ead;">RUN </span><span>mkdir /workspace
</span><span style="color:#b48ead;">COPY</span><span> ./* /workspace
</span><span style="color:#b48ead;">WORKDIR </span><span>/workspace
</span></code></pre>
<p>就是选个操作系统镜像基底，在根目录下建个 <code>/workspace</code> 作为容器的工作目录，再把
context 即 <code>my-program-release/</code> 目录下的所有内容拷到镜像的 <code>/workspace</code> 中。
当然可以根据项目需要在 Dockerfile 中添加更多内容，这不多说。其实笔者向来推荐把
Dockerfile 本身也打进镜像中，将来运行容器时可以进去查看到这个文件，作为参考大
致了解该镜像是怎么来的。于是，可以把 Dockerfile 就放在 my-program-release 子目
录，而不是放在项目根目录。这样，在上面的 <code>make image</code> 目标下的 <code>docker build</code>
命令就不必加 <code>-f ./Dockerfile</code> 参数了。</p>
<p>另一个问题，<code>image</code> 目标依赖的 <code>TAR_DIR</code> ，也即 -release 目录的依赖与准备，若
按前面的叙述，分离到单独的 <code>tar.mk</code> 文件中了，在主控 makefile 文件中看不到它了
。有两个解决方案，一种是在 makefile 用中 <code>include tar.mk</code> 命令将那个文件包含进
来；一种是将 <code>image</code> 目标也写到 <code>tar.mk</code> 中，然后在 makefile 转调命令
<code>make image -f tar.mk</code> 。</p>
<p>镜像做好之后，需要先本地启个容器来测试。也就是说 <code>make start</code> 时不再跑 <code>bin/</code>
目录下的程序，而是运行容器，执行容器中的 <code>/workspace/bin/my-program</code> 。可以先
建个 <code>start.docker</code> 目标来表示这种启动方式，大概写法如下：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#bf616a;">CONTAINER_NAME </span><span>= </span><span style="color:#a3be8c;">--name </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SERVER_NAME</span><span style="color:#b48ead;">)
</span><span style="color:#8fa1b3;">CONTAINER_VOL = -v log</span><span>:</span><span style="color:#a3be8c;">/workspace/log
</span><span style="color:#bf616a;">CONTAINER_CMD </span><span>= </span><span style="color:#a3be8c;">-d bin/</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SERVER_NAME</span><span style="color:#b48ead;">)
</span><span style="color:#8fa1b3;">start.docker</span><span>:
</span><span>    </span><span style="color:#bf616a;">docker</span><span> run </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CONTAINER_VOL</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">CONTAINER_NAME</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">IMAGE_TAG</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">CONTAINER_CMD</span><span style="color:#b48ead;">)
</span></code></pre>
<p>容器启动往往涉及相当多的选项，为此我们定义几个变量，最后组成 <code>docker run</code> 命令
行参数，主要包括如下几部分：</p>
<ul>
<li>-v 挂载卷，把日志目录挂载为当前的 log/ 子目录，</li>
<li>--name 为容器取个名字，同服务程序名，方便其他 docker 命令引用</li>
<li>镜像名</li>
<li>要在容器中执行的命令，让程序在容器内的前台运行即可，不需 <code>nohup ... &amp;</code>，
<code>-d</code> 是 <code>docker run</code> 的选项，将容器置于后台运行。</li>
</ul>
<p>在容器中跑的服务，一般还会涉及端口映射，如用 <code>-p</code> 选项，这里也不多说了。</p>
<p>与 <code>start</code> 相对应的 <code>stop</code> 任务就简单多了，调个 <code>docker stop</code> 的事：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">stop.docker</span><span>:
</span><span>    </span><span style="color:#bf616a;">docker</span><span> stop </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CONTAINER_NAME</span><span style="color:#b48ead;">)
</span></code></pre>
<p>在本地的单机容器通过基本的验证测试后，就可以通过 <code>docker push</code> 推送到镜像仓库
了，这个命令与 <code>git push</code> 很像，对于商业项目，应该是推送到公司内部的镜像仓库。
这个目标任务的实现也简单：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#bf616a;">DOCKER_REGISTRY </span><span>= </span><span style="color:#a3be8c;">my.company.com/my-project
</span><span style="color:#bf616a;">IMAGE_REMOTE </span><span>= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">DOCKER_REGISTRY</span><span style="color:#b48ead;">)</span><span style="color:#a3be8c;">/</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">IMAGE_TAG</span><span style="color:#b48ead;">)
</span><span style="color:#8fa1b3;">push.docker</span><span>:
</span><span>    </span><span style="color:#bf616a;">docker</span><span> tag </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">IMAGE_TAG</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">IMAGE_REMOTE</span><span style="color:#b48ead;">)
</span><span>    </span><span style="color:#bf616a;">docker</span><span> push </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">IMAGE_REMOTE</span><span style="color:#b48ead;">)
</span></code></pre>
<p>这里需要配置镜像仓库地址 <code>DOCKER_REGISTRY</code> ，用 <code>docker tag</code> 命令为本地镜像多
打个新标签，加上仓库地址前缀，然后用 <code>docker push</code> 推送新标签。另外提一下，这
里的镜像标签中作为版本的后缀都是默认的 <code>:latest</code> ，这在严肃项目中需要对镜像作
版本管理区分时是不良实践。所以在推送 <code>:latest</code> 之后，最好额外打个有版本标识的
标签并推送，一般可用时间或 git 最近提交的 hash 码作为版本标识。比如增改如下：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#bf616a;">DOCKER_REGISTRY </span><span>= </span><span style="color:#a3be8c;">my.company.com/my-project
</span><span style="color:#bf616a;">CUR_TIME </span><span>= </span><span style="color:#b48ead;">$(</span><span style="color:#96b5b4;">shell </span><span style="color:#bf616a;">date</span><span style="color:#a3be8c;"> +</span><span>%</span><span style="color:#bf616a;">s</span><span style="color:#b48ead;">)
</span><span style="color:#bf616a;">IMAGE_REMOTE </span><span>= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">DOCKER_REGISTRY</span><span style="color:#b48ead;">)</span><span style="color:#a3be8c;">/</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">IMAGE_TAG</span><span style="color:#b48ead;">)
</span><span style="color:#bf616a;">IMAGE_VERSION </span><span>= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">DOCKER_REGISTRY</span><span style="color:#b48ead;">)</span><span style="color:#a3be8c;">/</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SERVER_NAME</span><span style="color:#b48ead;">)</span><span style="color:#a3be8c;">:</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CUR_TIME</span><span style="color:#b48ead;">)
</span><span style="color:#8fa1b3;">push.docker</span><span>:
</span><span>    </span><span style="color:#bf616a;">docker</span><span> tag </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">IMAGE_TAG</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">IMAGE_REMOTE</span><span style="color:#b48ead;">)
</span><span>    </span><span style="color:#bf616a;">docker</span><span> push </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">IMAGE_REMOTE</span><span style="color:#b48ead;">)
</span><span>    </span><span style="color:#bf616a;">docker</span><span> tag </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">IMAGE_TAG</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">IMAGE_VERSION</span><span style="color:#b48ead;">)
</span><span>    </span><span style="color:#bf616a;">docker</span><span> push </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">IMAGE_VERSION</span><span style="color:#b48ead;">)
</span></code></pre>
<h3 id="wei-mu-biao-de-touch-wen-jian">伪目标的 touch 文件</h3>
<p>上节的容器任务，还遗留了一个问题，如何避免重新制作镜像与推送镜像？对比打 <code>tar</code>
包就不存在这个问题，因为会生成一个 <code>.tar.gz</code> 文件，能与 <code>-release</code> 目录比较更
新时间，所以在执行 <code>make tar</code> 时只会在需要重新打包时才会执行命令。而 <code>image</code>
应该是个伪目标， make 它时不会在当前目录生成文件，生成的镜像被 docker 引擎统一
管理，不是很方便追踪它的更新时间。</p>
<p>为解决伪目标的这个问题，可以在执行完命令后 <code>touch</code> 一个文件，专门用于标记最近
执行目标的时间，可用以与依赖比较时间。当然这还需要一个中转，可改写如下：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#bf616a;">TOUCH_DIR </span><span>= </span><span style="color:#a3be8c;">.touch
</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TOUCH_DIR</span><span style="color:#b48ead;">)</span><span>:
</span><span>    </span><span style="color:#bf616a;">mkdir -p $@
</span><span>
</span><span style="color:#bf616a;">image_touch </span><span>= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TOUCH_DIR</span><span style="color:#b48ead;">)</span><span style="color:#a3be8c;">/image.touch
</span><span style="color:#8fa1b3;">image</span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">image_touch</span><span style="color:#b48ead;">)
</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">image_touch</span><span style="color:#b48ead;">)</span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TAR_DIR</span><span style="color:#b48ead;">)
</span><span>    </span><span style="color:#bf616a;">docker</span><span> build </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TAR_DIR</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;"> -t </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">IMAGE_TAG</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;"> -f</span><span> ./Dockerfile
</span><span>    </span><span style="color:#d08770;">@</span><span style="color:#bf616a;">mkdir -p </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TOUCH_DIR</span><span style="color:#b48ead;">)
</span><span>    </span><span style="color:#bf616a;">touch $@
</span></code></pre>
<p>以上，先规划建一个 <code>.touch/</code> 子目录，专门用于收集 <code>touch</code> 文件，隐藏目录，平时
眼不见为净。然后让伪目标 <code>image</code> 依赖真实文件 <code>.touch/image.touch</code> ，而后者，
就是之前第一版写的 <code>image</code> 目标与命令实现，只不过之后在执行完 <code>docker build</code>
后加条 <code>touch .touch/.image.touch</code> 命令，为伪目标 <code>image</code> 更新对应的 touch 文
件时间。使用时，仍然执行 <code>make image</code> ，只有当检测到 touch 文件比打包目录更旧
了，才需重新制作镜像。</p>
<p>推送镜像也同理可改造一下，它依赖的目标是制作镜像：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#bf616a;">push_touch </span><span>= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TOUCH_DIR</span><span style="color:#b48ead;">)</span><span style="color:#a3be8c;">/push.touch
</span><span>
</span><span style="color:#8fa1b3;">push.docker</span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">push_touch</span><span style="color:#b48ead;">)
</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">push_touch</span><span style="color:#b48ead;">)</span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">image_touch</span><span style="color:#b48ead;">)
</span><span>    </span><span style="color:#bf616a;">docker</span><span> tag </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">IMAGE_TAG</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">IMAGE_REMOTE</span><span style="color:#b48ead;">)
</span><span>    </span><span style="color:#65737e;"># ...
</span><span>    </span><span style="color:#bf616a;">touch $@
</span></code></pre>
<p>这样，在已经推送过最近制作的镜像时，再（由于忘记或不确定时）重复执行
<code>make push.docker</code> 是不会触发重复推送的。</p>
<p>其他伪目标，如有需要，都可以按这种方式加个对应的 touch 文件。是否需要重构依赖
链都另说，至少可以作为一个曾经执行与最近执行的证据。比如 <code>make start</code> ，就可以
加条 <code>touch .touch/start.touch</code> 命令，标记启动时间。当然，如果服务本身会写 pid
文件，pid 文件也是启动时间的一个标记。</p>
<p>顺便提一下，若从头开始只用 <code>touch</code> 一个不存在的文件，它只会创建 0 字节的空文件，
0 字节文件不会占用额外硬盘空间，只是在父目录的表项中多添加一记录，相当于只修改
父目录这个“文件”。当然了，现在的硬盘并不值钱，并不需要刻意追求 0 字节文件，所
以也可能改用 <code>echo ... &gt; .touch/target.touch</code> 代替 <code>touch</code> 命令往目标的 touch
文件写入一些你觉得有意义的内容。</p>
<h3 id="duo-chong-shi-xian-fang-shi-de-qie-huan">多种实现方式的切换</h3>
<p>至此，我们在 makefile 中为服务程序先后实现了几种启动方式：</p>
<ol>
<li>用 bash 脚本或命令行在本地启动；</li>
<li>用 systemctl 启动，纳入 systemd 服务管理系统；</li>
<li>用容器启动。</li>
</ol>
<p>显然，在某一时期，或某个环境中，你只会用到其中一种方式启动服务。现在，第 1 种
最原始的方式占用了最简短的 <code>start</code> 目标，好像不妥当。所以再作个优化，将第 1 种
<code>start</code> 改名为 <code>start.bash</code> ，再重新建一个 <code>start</code> 目标，让它依赖以上三者之一
，例如，默认使用第 3 种的容器启动：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">start.bash</span><span>:
</span><span>    </span><span style="color:#65737e;"># script/start.sh ...
</span><span>
</span><span style="color:#8fa1b3;">start.sd</span><span>:
</span><span>    </span><span style="color:#65737e;"># systemctl start ...
</span><span>
</span><span style="color:#8fa1b3;">start.docker</span><span>:
</span><span>    </span><span style="color:#65737e;"># docker run ...
</span><span>
</span><span style="color:#8fa1b3;">start</span><span>: </span><span style="color:#a3be8c;">start.docker
</span></code></pre>
<p>这种依赖关系，如果不是伪目标，而是当成真实文件看，就有点像软链接的味道了，相当
于这样：</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">ln -s</span><span> start.docker start
</span></code></pre>
<p>停止服务的伪目标，也可以作类似的“软链接”处理。</p>
<p>至此，小结一下，这里讨论的名为 <code>my-program</code> 的示例项目文件与目录结构大致如下：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>my-program/
</span><span>  - .touch/
</span><span>  - build/
</span><span>  - scr/
</span><span>  - script/
</span><span>  - bin/
</span><span>  - lib/
</span><span>  - log/
</span><span>  - my-program-release/
</span><span>  - my-program-release.tar.gz
</span><span>  - makefile
</span><span>  - tar.mk
</span><span>  - CMakeLists.txt
</span><span>  - Dockerfile
</span></code></pre>
<p>其中，<code>makefile</code> 文件就是本文重点讨论的，把 make 当作能自定义子命令的管理脚本
或主控脚本，它可能会调用另一个 makefile 文件 <code>tar.mk</code> 及 <code>script/</code> 目录下的脚
本。一些伪目标的执行，可能在隐藏目录 <code>.touch</code> 下更新相应的 touch 文件的时间戳。</p>
<h2 id="makefile-jiao-ben-chang-yong-ji-qiao">Makefile 脚本常用技巧</h2>
<p>从核心功能与原理上讲，makefile 可以是简单的。但随着目标的广度与依赖的深度增加，
makefile 也可能会逐渐变得复杂，尤其是 makefile 也支持变量、函数、条件，甚至循
环等常规编程元素。关于具体的语法，本文不想深入讲太细，请在需要时搜索相应的参考
文档。除了建议对 makefile 保持简单、控制规模外，下面再讲一些笔者认为比较重要的
几个点。</p>
<h3 id="diao-shi-shou-duan">调试手段</h3>
<p>首先，从脚本编程角度看，大多语言都应该有只检查语法而不执行的手段。make 也有个
<code>-n</code> 选项，它只打印目标将要执行的命令，而不实际执行。它在分析 makefile 中目标
依赖关系过程中，自然也能检测出语法错误，而“业务”逻辑错误，则要从它打印的命令
人工分析了，看它是否符合预期想执行的命令序列。</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#65737e;"># 打印默认目标将要执行的命令
</span><span style="color:#bf616a;">make -n
</span><span>
</span><span style="color:#65737e;"># 打印指定目标将要执行的命令
</span><span style="color:#bf616a;">make -n</span><span> target
</span><span>
</span><span style="color:#65737e;"># 检查打印命令无误时，再去掉 -n 实际执行
</span><span style="color:#bf616a;">make</span><span> target</span><span style="color:#bf616a;"> -n
</span><span style="color:#bf616a;">make</span><span> target
</span></code></pre>
<p>按命令行程序解析参数的习惯，<code>-n</code> 选项位置无关，我建议写在最后，这更方便输入命
令行过程中的顺手修改。</p>
<p>如果指定的目标按 make 的依赖逻辑“最新的”，<code>make -n</code> 也能指出这点，不会打印任何
命令。如果目标依赖链缺失，它能报告错误，这也是重要的诊断信息。例如，我们在前文
介绍的最“复杂”的目标，应该是打包任务。如果从代码库拉下新鲜代码还没编译前就测试
这个目标：</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">make</span><span> tar</span><span style="color:#bf616a;"> -f</span><span> tar.mk</span><span style="color:#bf616a;"> -n
</span></code></pre>
<p>它就会报错。大致原因是 <code>tar</code> 目标依赖 -release/ 目录下的文件，后者依赖编译结果
放在 bin/ 目录下的文件，而这些待打包的各个文件，我们没有在之前的 makefile 中给
出依赖，告诉 make 在缺失时该调用什么命令生成它们。所以 make 报告这是依赖错误。
这个错误可大可小，毕竟正常情况下，我们不会在编译之前就搞打包操作。只要先执行
<code>make build</code> 正常编译后，再测试 <code>make tar -n</code> 就不会报错了。</p>
<p>当知道这个错误根源后，要修改也就容易了，虽然实际上未必重要。只要增加待打包文件
依赖 <code>build</code> 目标就行：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">FILE_LIST</span><span style="color:#b48ead;">)</span><span>: </span><span style="color:#a3be8c;">build
</span></code></pre>
<p>这句话告诉 make ，当你发现任何待打包文件缺失时，请先执行 <code>build</code> 目标。</p>
<p>其次，print 大法也是调试一切编程语言或脚本的简单粗暴姿式。makefile 也能用几个
内置函数来打印消息，例如：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#b48ead;">$(</span><span style="color:#96b5b4;">info </span><span>will tar these files </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">FILE_LIST</span><span style="color:#b48ead;">))
</span><span style="color:#b48ead;">$(</span><span style="color:#96b5b4;">warning </span><span>this is just warning message</span><span style="color:#b48ead;">)
</span><span style="color:#b48ead;">$(</span><span style="color:#96b5b4;">error </span><span>fatol error occurs and would exit</span><span style="color:#b48ead;">)
</span></code></pre>
<p>其中，<code>error</code> 函数被调用时会视为错误，打印后退出 make ，所以这一般应放在条件判
断语句块中，或者可用于标记某个目标为弃用状态，不该再被执行。其他两个函数在打印
消息后会继续处理 makefile 语句，以调试为目的打印建议使用 <code>info</code> ，打字省流，不
过 <code>warning</code> 有个好处是还会打印所在文件名与行号。例如：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#b48ead;">$(</span><span style="color:#96b5b4;">warning </span><span>target err should not be called</span><span style="color:#b48ead;">)
</span><span style="color:#b48ead;">$(</span><span style="color:#96b5b4;">info </span><span>target err should not be called</span><span style="color:#b48ead;">)
</span><span style="color:#8fa1b3;">err</span><span>:
</span><span>    </span><span style="color:#b48ead;">$(</span><span style="color:#96b5b4;">error </span><span>this target is deprressed</span><span style="color:#b48ead;">)
</span></code></pre>
<p>消息打印有个恼人的地方是，如果它不是放在条件语句块内，它总是会打印出来，这在调
试完后是每次 make 都可能出现的噪音。除了把打印注释掉，我还推荐一个办法，可以专
门设立一个打印目标，把当前 makefile 中用到的关键变量打印出来，例如：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">echo</span><span>:
</span><span>    </span><span style="color:#d08770;">@</span><span style="color:#96b5b4;">echo</span><span> CUR_TIME = </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CUR_TIME</span><span style="color:#b48ead;">)
</span><span>    </span><span style="color:#d08770;">@</span><span style="color:#96b5b4;">echo</span><span> FILE_LIST = </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">FILE_LIST</span><span style="color:#b48ead;">)
</span><span>    </span><span style="color:#d08770;">@</span><span style="color:#96b5b4;">echo</span><span> FILE_INTAR = </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">FILE_INTAR</span><span style="color:#b48ead;">)
</span></code></pre>
<p>这样，执行 <code>make echo</code> 就起到监视变量的作用了，这在你不确认某些变量操作时很有用。</p>
<h3 id="can-shu-chuan-di">参数传递</h3>
<p>将复杂任务拆成几个小任务，是编程的另一个基本操作。makefile 的目标，也是一种细
粒度的拆分，或可类比为结构化编程语言最常见的函数或子过程，而目标之间的依赖，也
就相当于过程调用。例如再回顾前面的一个示例：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">all</span><span>: </span><span style="color:#a3be8c;">build restart log
</span><span style="color:#8fa1b3;">restart</span><span>: </span><span style="color:#a3be8c;">stop start
</span></code></pre>
<p>当在 shell 中执行 <code>make all</code> 时，就相当于依次执行 <code>make build stop start log</code>
这几个目标。当其他语言将一个大任务拆成几个任务再组合起来时，那些子任务的执行顺
序也就固定了。而 make 还可以在命令行中单独激活中间某个或几个子任务，这种灵活性
也表明 make 是面向终端用户的。</p>
<p>在同一个 makefile 中，不同目标的过程调用，可认为不涉及参数传递，大家都使用全局
变量。当 makefile 规模增长到一定程度，可以根据业务关联度将一部分代码拆出为独立
的 makefile 文件，就如之前讨论的 <code>tar.mk</code> 文件。如果在主文件中用 <code>include</code> 指
令将子文件重新包含进来，那在 make 看来，还是同一个文件。</p>
<p>所以这里只讨论真正拆分 makefile 后，在主文件使用 <code>make -f sub-split.mk</code> 方式调
用子文件时的一些问题。就比如，之前的 <code>tar.mk</code> 文件中，也用到了 <code>SERVER_NAME</code>
这个变量，但是未定义。当然，可以在 <code>tar.mk</code> 补上定义，但重复代码总归不好。更好
方式是在调用时传递参数，可以这样写：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">tar</span><span>:
</span><span>    </span><span style="color:#bf616a;">make -f</span><span> tar.mk SERVER_NAME=</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SERVER_NAME</span><span style="color:#b48ead;">)
</span></code></pre>
<p>在 make 的命令行参数约定中，<code>VARNAME=value</code> 形式表示在相应的 makefile 中增加变
量定义。这形式有点像环境变量定义，但也像是 <code>--option=argument</code> 形式省略了前缀
<code>--</code> 的简化。因为带 <code>-</code> 或 <code>--</code> 前缀的选项，是传递给 make 程序本身使用的，而不
是给 makefile 脚本使用的。另外，虽然 makefile 变量习惯用大写的居多，但使用小写
也没问题。</p>
<p>在上例中，<code>$(SERVER_NAME)</code> 先在当前 makefile 解析时被展开为它的值，所以传递给
<code>tar.mk</code> 的变量定义就类似 <code>SERVER_NAME=my-program</code> ，也就继承了主文件的变量值。
不过在 <code>tar.mk</code> 文件中完全没体现有这个变量定义，也是不好，在将来维护修改时可能
感觉困惑，并且无法单独使用。因此，推荐用 <code>?=</code> 给它一个默认值，如：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#65737e;"># tar.mk
</span><span style="color:#bf616a;">SERVER_NAME </span><span>?= </span><span style="color:#a3be8c;">my-program
</span></code></pre>
<p>这条语句，只在 <code>SERVER_NAME</code> 变量未定义时才执行，正好满足两方面的需求。</p>
<p>对于一些复杂任务，如果不适合削足适履用 makefile 来写，完全可调用一个 bash 脚本
或其他脚本程序来写，尤其是已经有脚本实现功能的情况下，只在 makefile 中为 make
注册一个快速目标入口就好，这可达到简化命令行输入的效果。</p>
<p>当被调用的其他（语言）脚本有处理命令行参数功能时，在 makefile 的某个目标下写命
令时也只要按其要求传入选项参数即可，可适当利用 makefile 的变量展开功能达到简化
与动态传参的效果，比如上文介绍的为 <code>docker run</code> 命令传参。</p>
<p>再举个简单例子，我们在监控日志时还经常需要根据某个关键字过滤，只打印匹配行，就
类似如下命令行的意图：</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">tail -f</span><span> last.log | </span><span style="color:#bf616a;">grep</span><span> key
</span></code></pre>
<p>其中，最近的日志可用类似 <code>ls -rt log/ | tail -1</code> 找出，拼起来略有复杂，值得封
装成一个脚本，则该脚本显然应该接收一个参数表示 grep 什么 key 。简单实现如下：</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#65737e;">#!/bin/bash
</span><span style="color:#65737e;"># file: script/lastlogf.sh
</span><span>
</span><span style="color:#bf616a;">last</span><span>=$</span><span style="color:#a3be8c;">(</span><span style="color:#bf616a;">ls -rt</span><span style="color:#a3be8c;"> log/</span><span>* | </span><span style="color:#bf616a;">tail -1</span><span style="color:#a3be8c;">)
</span><span style="color:#bf616a;">tail -f </span><span>$</span><span style="color:#bf616a;">last </span><span>| </span><span style="color:#bf616a;">grep </span><span>$</span><span style="color:#bf616a;">1
</span></code></pre>
<p>直接从命令行调用大约如下，要求实时打印含 Error 的日志：</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">script/lastlogf.sh</span><span> Error
</span></code></pre>
<p>如果在 makefile 中设立一个 logf 目标，可写成如下：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">logf</span><span>:
</span><span>    </span><span style="color:#bf616a;">script/lastlogf.sh </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">grepkey</span><span style="color:#b48ead;">)
</span></code></pre>
<p>其中，<code>grepkey</code> 变量需要通过 <code>make</code> 命令行传参，写成如下：</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">make</span><span> logf grepkey=Error
</span></code></pre>
<p>与前面直接调用 <code>script/lastlogf.sh</code> 输入量差似乎不多。不过当你习惯了 make 的这
种用法，之后专为 make 调用增加新脚本时，也可以借鉴 make 那种通过环境变量的方式
传参。例如，将脚本改写成：</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#65737e;">#!/bin/bash
</span><span style="color:#65737e;"># file: script/lastlogf.sh
</span><span>
</span><span style="color:#bf616a;">last</span><span>=$</span><span style="color:#a3be8c;">(</span><span style="color:#bf616a;">ls -rt</span><span style="color:#a3be8c;"> log/</span><span>* | </span><span style="color:#bf616a;">tail -1</span><span style="color:#a3be8c;">)
</span><span style="color:#bf616a;">tail -f </span><span>$</span><span style="color:#bf616a;">last </span><span>| </span><span style="color:#bf616a;">grep </span><span>$</span><span style="color:#bf616a;">grepkey
</span></code></pre>
<p>对比前后两个版本，可见就只有 <code>$1</code> 与 <code>$grepkey</code> 的区别，也就相当于位置参数与命
名参数的区别。它们各有优劣，本文不再额外讨论。此外，为简便起见，这两个版本都没
对参数判空处理，实际中在缺少（位置）参数或环境变量时，最好赋个默认值，否则会出
错。</p>
<p>对于后一个版本的 <code>lastlogf.sh</code> 脚本，makefile 为目标传参的写法是：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">logf</span><span>:
</span><span>    </span><span style="color:#bf616a;">grepkey</span><span>=</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">grepkey</span><span style="color:#b48ead;">) </span><span style="color:#bf616a;">script/lastlogf.sh
</span></code></pre>
<p>通过命令行执行 make 的写法却不用变，仍然是：</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">make</span><span> logf grepkey=Error
</span></code></pre>
<p>但若要从命令行直接调用脚本，就要写成：</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">grepkey</span><span>=</span><span style="color:#a3be8c;">Error </span><span style="color:#bf616a;">script/lastlogf.sh
</span></code></pre>
<p>在 bash 命令行中，将 <code>key=val</code> 等式写在命令之前，表示专门为该命令（将启的进程
）设置环境变量，而不影响当前 session 的环境变量。当然了，所谓污染当前会话的环
境变量的影响也许没那么大，如果不在意的话，也可以先 <code>export</code> 写成：</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#b48ead;">export </span><span style="color:#bf616a;">grepkey</span><span>=</span><span style="color:#a3be8c;">Error
</span><span style="color:#bf616a;">script/lastlogf.sh
</span></code></pre>
<p>这样，当为 <code>grepkey</code> 导出环境变量后，就可免参调用脚本了。这里，我将“命名参数
”用小写字母表示，既为输入方便，也好与常规环境变量区分。</p>
<p>而在 makefile 中，也是能导出环境变量的，故也能这样写：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#65737e;"># grepkey 的值由 make 的命令行参数设定
</span><span style="color:#65737e;"># export 只声明要将其导出为环境变量
</span><span style="color:#b48ead;">export</span><span style="color:#bf616a;"> grepkey
</span><span style="color:#8fa1b3;">logf</span><span>:
</span><span>    </span><span style="color:#bf616a;">script/lastlogf.sh
</span></code></pre>
<p>只不过在 makefile ，由于只要一次写定，所以按之前的写法，为单行命令局部导出环境
变量可能是更优的实现。另外，在输入 make 的命令行参数时，其实也可以将“命名参数
”写在 <code>make</code> 前面，如：</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">grepkey</span><span>=</span><span style="color:#a3be8c;">Error </span><span style="color:#bf616a;">make</span><span> logf
</span></code></pre>
<p>这种写法，也是为 make 进程设定环境变量。只不过在随后 make 进程解析 makefile 时
，makefile 定义的变量与环境变量几乎是可互用的。但是很显然，“命名参数”前置的
写法看起来有点奇怪，make 能将其后置，才是更符合直觉的写法。</p>
<p>这里讨论这一番，主要是想表达一个观点，当要开发 bash 脚本与 makefile 联用时，采
用环境变量的“命名参数”法会使风格会更统一。在 bash 脚本，引用环境变量是很方便
的，对比其他通用脚本语言要获取环境变量可能还要经过库函数调用。不过其他编程语言
，也大多有很好用的命令行参数解析库，能支持长横短横引导选项，有参无参混合等复杂
情况的解析。而 bash 脚本，虽然也有内置库函数能解析命令行参数，但我觉得很不优雅
，不如就用环境变量，再通过 make 中转一下，就妥妥的命名参数的风格。</p>
<p>如果觉得给 make 提供命名参数，仍然要多敲不少字符，那还有一种情况，可以根据脚本
最常用参数，在 makefile 中为脚本的典型用法设立不同的目标，以达到简化输入的目的
。</p>
<p>例如，也是常见的任务，假如开发机硬盘空间告急，需要删除旧日志文件。虽然写个定时
任务也是个可行方案，但是只在必要时手动删也是个不同的选择。思路也简单，先用
<code>find</code> 命令找到更新时间在几天的日志文件，再用 <code>rm</code> 删除之。但是我从来记不住
find 的具体用法，所以把它封装成 bash 脚本，通过命令行输入“多少天前”的参数。
脚本实现且不论，就说写好了取名为 <code>rmlog.sh</code> 吧。然后在 makefile 中建立三个目标
，分别表示删除 1 天前的日志，删除 7 天前的日志，与删除 30 天前的日志：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">log.rm1</span><span>:
</span><span>    </span><span style="color:#bf616a;">script/rmlog.sh</span><span> 1
</span><span style="color:#8fa1b3;">log.rm7</span><span>:
</span><span>    </span><span style="color:#bf616a;">script/rmlog.sh</span><span> 7
</span><span style="color:#8fa1b3;">log.rm30</span><span>:
</span><span>    </span><span style="color:#bf616a;">script/rmlog.sh</span><span> 30
</span></code></pre>
<p>使用时就只要执行类似 <code>make log.rm7</code> 的命令。仅管脚本支持输入任意正整数表示几天
前，但我表示没必要，有这三档删除给我日常使用就够了。而且 makefile 屏蔽了脚本对
参数格式的具体要求，即使后来 <code>rmlog.sh</code> 优化升级了，增加了许多高级功能，也只要
在 makefile 中对传参作适配，不影响 make 的终端用户。即使偶尔用户有输入非常规参
数的需求，也可以用 <code>make -n</code> 把示例命令打印出来，让用户拷下来，在那基础上改改
参数值，并不太需要记忆背后脚本的参数格式约定。</p>
<h2 id="jie-yu">结语</h2>
<p>本文结合 Linux 开发的日常任务，介绍与探讨了将 make 当作自定义子命令的管理工具
的清奇用法。核心要点包括：</p>
<ul>
<li>makefile 设定的目标成为 make 可执行的子命令；</li>
<li>makefile 建立的目标依赖代表了 make 子命令的顺序与组合；</li>
<li>make 子命令以伪目标为主，可以更新对应的 touch 文件标记时间及传递依赖；</li>
<li>可以利用 makefile 的诸多编程特性，从简单的变量与函数，到复杂的分支与循环；</li>
<li>目标指令可调用其他 makefile 或脚本，简化常用任务的命令行输入。</li>
</ul>
<p>通过 makefile 及其组织、管理的一系列可大可小的脚本，能够简捷地在 bash 脚本层面
实现子命令模式，从而让 make 这个古老的工具焕发现代的气息。而若想使用纯 bash 脚
本实现子命令模式，那可能是相当复杂与困难的。</p>
<h2 id="fu-lu-can-kao-lian-jie">附录：参考链接</h2>
<ul>
<li>GNU make 官方手册 <a href="https://www.gnu.org/software/make/manual/html_node/index.html">https://www.gnu.org/software/make/manual/html_node/index.html</a></li>
</ul>
<h2 id="fu-lu-ben-wen-ji-yuan-ma">附录：本文集源码</h2>
<p>依 makefile 的语法要求，目标下面的命令行是制表符缩进，网页渲染的代码很可能转为
空格，不能直接复制使用，故提供本文的参考源码下载。</p>
<p><a href="https://lymslive.github.io/blog/make-as-sub-command/makefile">makefile</a> <a href="https://lymslive.github.io/blog/make-as-sub-command/tar.mk">tar.mk</a></p>

          </div>
        </article>
      </div>
      
      <div class="column is-2 is-hidden-mobile">
        <aside class="menu" style="position: sticky; top: 48px">
          <p class="heading has-text-weight-bold">目录</p>
          <ul class="menu-list">
            
            <li>
              <a id="link-yin-yan" class="toc is-size-7 is-active"
                href="https://lymslive.github.io/blog/make-as-sub-command/#yin-yan">
                引言
              </a>
              
            </li>
            
            <li>
              <a id="link-yong-make-zu-zhi-zi-ming-ling-jiao-ben" class="toc is-size-7 "
                href="https://lymslive.github.io/blog/make-as-sub-command/#yong-make-zu-zhi-zi-ming-ling-jiao-ben">
                用 make 组织子命令脚本
              </a>
              
              <ul>
                
                <li>
                  <a id="link-dian-xing-kai-fa-chang-jing-de-ri-chang-ren-wu" class="toc is-size-7" href="https://lymslive.github.io/blog/make-as-sub-command/#dian-xing-kai-fa-chang-jing-de-ri-chang-ren-wu">
                    典型开发场景的日常任务
                  </a>
                </li>
                
                <li>
                  <a id="link-makefile-tong-yi-guan-li" class="toc is-size-7" href="https://lymslive.github.io/blog/make-as-sub-command/#makefile-tong-yi-guan-li">
                    Makefile 统一管理
                  </a>
                </li>
                
                <li>
                  <a id="link-bang-zhu-xin-xi-make-help" class="toc is-size-7" href="https://lymslive.github.io/blog/make-as-sub-command/#bang-zhu-xin-xi-make-help">
                    帮助信息 make help
                  </a>
                </li>
                
              </ul>
              
            </li>
            
            <li>
              <a id="link-zi-ming-ling-jiao-ben-you-hua-tan-tao" class="toc is-size-7 "
                href="https://lymslive.github.io/blog/make-as-sub-command/#zi-ming-ling-jiao-ben-you-hua-tan-tao">
                子命令脚本优化探讨
              </a>
              
              <ul>
                
                <li>
                  <a id="link-gou-jian-make-build" class="toc is-size-7" href="https://lymslive.github.io/blog/make-as-sub-command/#gou-jian-make-build">
                    构建 make build
                  </a>
                </li>
                
                <li>
                  <a id="link-yun-xing-make-start-stop" class="toc is-size-7" href="https://lymslive.github.io/blog/make-as-sub-command/#yun-xing-make-start-stop">
                    运行 make start stop
                  </a>
                </li>
                
                <li>
                  <a id="link-shi-yong-systemd-guan-li-fu-wu-yun-xing" class="toc is-size-7" href="https://lymslive.github.io/blog/make-as-sub-command/#shi-yong-systemd-guan-li-fu-wu-yun-xing">
                    使用 systemd 管理服务运行
                  </a>
                </li>
                
                <li>
                  <a id="link-da-bao-ren-wu-make-tar" class="toc is-size-7" href="https://lymslive.github.io/blog/make-as-sub-command/#da-bao-ren-wu-make-tar">
                    打包任务 make tar
                  </a>
                </li>
                
                <li>
                  <a id="link-rong-qi-hua-ying-yong-ren-wu" class="toc is-size-7" href="https://lymslive.github.io/blog/make-as-sub-command/#rong-qi-hua-ying-yong-ren-wu">
                    容器化应用任务
                  </a>
                </li>
                
                <li>
                  <a id="link-wei-mu-biao-de-touch-wen-jian" class="toc is-size-7" href="https://lymslive.github.io/blog/make-as-sub-command/#wei-mu-biao-de-touch-wen-jian">
                    伪目标的 touch 文件
                  </a>
                </li>
                
                <li>
                  <a id="link-duo-chong-shi-xian-fang-shi-de-qie-huan" class="toc is-size-7" href="https://lymslive.github.io/blog/make-as-sub-command/#duo-chong-shi-xian-fang-shi-de-qie-huan">
                    多种实现方式的切换
                  </a>
                </li>
                
              </ul>
              
            </li>
            
            <li>
              <a id="link-makefile-jiao-ben-chang-yong-ji-qiao" class="toc is-size-7 "
                href="https://lymslive.github.io/blog/make-as-sub-command/#makefile-jiao-ben-chang-yong-ji-qiao">
                Makefile 脚本常用技巧
              </a>
              
              <ul>
                
                <li>
                  <a id="link-diao-shi-shou-duan" class="toc is-size-7" href="https://lymslive.github.io/blog/make-as-sub-command/#diao-shi-shou-duan">
                    调试手段
                  </a>
                </li>
                
                <li>
                  <a id="link-can-shu-chuan-di" class="toc is-size-7" href="https://lymslive.github.io/blog/make-as-sub-command/#can-shu-chuan-di">
                    参数传递
                  </a>
                </li>
                
              </ul>
              
            </li>
            
            <li>
              <a id="link-jie-yu" class="toc is-size-7 "
                href="https://lymslive.github.io/blog/make-as-sub-command/#jie-yu">
                结语
              </a>
              
            </li>
            
            <li>
              <a id="link-fu-lu-can-kao-lian-jie" class="toc is-size-7 "
                href="https://lymslive.github.io/blog/make-as-sub-command/#fu-lu-can-kao-lian-jie">
                附录：参考链接
              </a>
              
            </li>
            
            <li>
              <a id="link-fu-lu-ben-wen-ji-yuan-ma" class="toc is-size-7 "
                href="https://lymslive.github.io/blog/make-as-sub-command/#fu-lu-ben-wen-ji-yuan-ma">
                附录：本文集源码
              </a>
              
            </li>
            
          </ul>
        </aside>
      </div>
      
    </div>
  </div>
</section>


  
  <section class="modal" id="search-modal">
    <div class="modal-background"></div>
    <div class="modal-card">
      <header class="modal-card-head">
        <p class="modal-card-title">Search</p>
      </header>
      <section class="modal-card-body">
        <div class="field mb-2">
          <div class="control">
            <input class="input" id="search" placeholder="Search this website." type="search" />
          </div>
        </div>
        <div class="search-results">
          <div class="search-results__items"></div>
        </div>
      </section>
    </div>
    <button aria-label="close" class="modal-close is-large"></button>
  </section>
  


  

<section class="section">
  <div class="container">
    <div class="columns is-centered">
      <div class="column is-8">
        <nav class="level">
              
          <div class="level-item has-text-centered">
            <a class="button is-black is-outlined" href="https:&#x2F;&#x2F;lymslive.github.io&#x2F;blog&#x2F;rapidjson-deepin-learn-practice&#x2F;">
              <span class="icon mr-2">
                <i class="fas fa-arrow-circle-left"></i>
              </span>
              深入浅出理解 rapidjson 与实践
            </a>
          </div>
           
          <div class="level-item has-text-centered">
            <a class="button is-black is-outlined" href="https:&#x2F;&#x2F;lymslive.github.io&#x2F;blog&#x2F;cut-and-restore-cstr&#x2F;">
              C++ 奇淫技巧之耦断丝连：临时 C 字符串<span class="icon ml-2">
                <i class="fas fa-arrow-circle-right"></i>
              </span>
            </a>
          </div>
          
        </nav>
      </div>
    </div>
  </div>
</section>



  



  
  <footer class="footer py-4">
    <div class="content has-text-centered">
      <p>
        Contact
        <a class="has-text-black" href="mailto:403708621@qq.com" target="_blank">
          <span class="icon is-large" title="Email">
            <i class="far fa-envelope fa-lg"></i>
          </span>
        </a>
        Issue
        <a class="has-text-github" href="https://github.com/lymslive/lymslive.github.io/issues" target="_blank">
          <span class="icon is-large" title="GitHub">
            <i class="fab fa-github fa-lg"></i>
          </span>
        </a>
      </p>
      <p>
        Powered by
        <span class="icon-text">
          <span class="icon">
            <i class="fas fa-power-off"></i>
          </span>
          <span>zola</span>
        </span>
        with
        <span class="icon-text">
          <span class="icon">
            <i class="fas fa-code"></i>
          </span>
          <span>code</span>
        </span>
        and
        <span class="icon-text">
          <span class="icon">
            <i class="fas fa-heart"></i>
          </span>
          <span>love</span>
        </span>
      </p>
    </div>
  </footer>
  

  
  
  
  
  <script src="https://lymslive.github.io/elasticlunr.min.js"></script>
  <script src="https://lymslive.github.io/search_index.en.js"></script><script src="https://lymslive.github.io/js/site.js"></script>

  

<script type="text/javascript">
  const menuBarHeight = document.querySelector("nav.navbar").clientHeight;
  const tocItems = document.querySelectorAll(".toc");
  const navSections = new Array(tocItems.length);

  tocItems.forEach((el, i) => {
    let id = el.getAttribute("id").substring(5);
    navSections[i] = document.getElementById(id);
  })

  function isVisible(tocIndex) {
    const current = navSections[tocIndex];
    const next = tocIndex < tocItems.length - 1 ? navSections[tocIndex + 1]
      : document.querySelectorAll("section.section").item(1);

    const c = current.getBoundingClientRect();
    const n = next.getBoundingClientRect();
    const h = (window.innerHeight || document.documentElement.clientHeight);

    return (c.top <= h) && (n.top - menuBarHeight >= 0);
  }

  function activateIfVisible() {
    for (b = true, i = 0; i < tocItems.length; i++) {
      if (b && isVisible(i)) {
        tocItems[i].classList.add('is-active');
        b = false;
      } else
        tocItems[i].classList.remove('is-active');
    }
  }

  var isTicking = null;
  window.addEventListener('scroll', () => {
    if (!isTicking) {
      window.requestAnimationFrame(() => {
        activateIfVisible();
        isTicking = false;
      });
      isTicking = true;
    }
  }, false);
</script>





  
<script src="https://lymslive.github.io/js/chinese-format.js"></script>

</body>

</html>
