<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1" name="viewport" />
  <meta content="#ffffff" name="theme-color" />
  <meta content="#da532c" name="msapplication-TileColor" />

  
  
  
  
  

  

  

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1.9.1/css/academicons.min.css" integrity="sha384-FIue+PI4SsI9XfHCz8dBLg33b0c1fMJgNU3X//L26FYbGnlSEfWmNT7zgWc2N9b6" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link href="https://lymslive.github.io/deep-thought.css" rel="stylesheet" />
  
<link href="/page-patch.css" rel="stylesheet" />


  <title>
    
沉思涧 | 浅谈 GNU Make 构建项目实践

  </title>

  
  
  

  
</head>

<body class="has-background-white">
  <nav aria-label="section navigation" class="navbar is-light" role="navigation">
    <div class="container">
      <div class="navbar-brand">
        <a class="navbar-item is-size-5 has-text-weight-bold" href="https:&#x2F;&#x2F;lymslive.github.io">沉思涧</a>
        <a aria-expanded="false" aria-label="menu" class="navbar-burger burger" data-target="navMenu" role="button">
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
          <span aria-hidden="true"></span>
        </a>
      </div>
      <div class="navbar-menu" id="navMenu">
        <div class="navbar-end has-text-centered">
          
          
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;lymslive.github.io&#x2F;">
            首页
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;lymslive.github.io&#x2F;blog">
            博客
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;lymslive.github.io&#x2F;book">
            书册
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;lymslive.github.io&#x2F;think">
            文思
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;lymslive.github.io&#x2F;white">
            白学
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;lymslive.github.io&#x2F;tags">
            标签
          </a>
          
          <a class="navbar-item has-text-weight-semibold" href="https:&#x2F;&#x2F;lymslive.github.io&#x2F;categories">
            归类
          </a>
          
          
          
          <a class="navbar-item" id="nav-search" title="Search" data-target="#search-modal">
            <span class="icon">
              <i class="fas fa-search"></i>
            </span>
          </a>
          <a class="navbar-item" id="dark-mode" title="Switch to dark theme">
            <span class="icon">
              <i class="fas fa-adjust"></i>
            </span>
          </a>
        </div>
      </div>
    </div>
  </nav>

  
  

  
<section class="section">
  <div class="container">
    <div class="columns">
      <div class="column is-8 is-offset-2">
        <article class="box">
          <h1 class="title">
            浅谈 GNU Make 构建项目实践
          </h1>
          <p class="subtitle"></p>
          <div class="columns is-multiline is-gapless">
            <div class="column is-8">
              
<span class="icon-text has-text-grey">
  <span class="icon">
    <i class="fas fa-user"></i>
  </span>
  <span>七阶子</span>
  <span class="icon">
    <i class="far fa-calendar-alt"></i>
  </span>
  <span><time datetime="2019-07-06">2019-07-06</time></span>
</span>

            </div>
            <div class="column is-4 has-text-right-desktop">
              
<span class="icon-text has-text-grey">
  <span class="icon">
    <i class="far fa-clock"></i>
  </span>
  <span>34 min,</span>
  <span class="icon">
    <i class="fas fa-pencil-alt"></i>
  </span>
  <span>6767 words</span>
</span>

            </div>
            <div class="column">
              
              
<p>
  归类：
  
  <a class="has-text-info-dark has-text-weight-semibold" href="https://lymslive.github.io/categories/gong-ju-shi-yong/">
    <span class="icon-text">
      <span class="icon">
        <i class="fas fa-cube"></i>
      </span>
      <span>工具使用</span>
    </span>
  </a>
  
</p>

              
            </div>
            <div class="column has-text-right-desktop">
              
              
<p>
  标签：
  
  <a class="has-text-info-dark has-text-weight-semibold" href="https://lymslive.github.io/tags/linux/">
    <span class="icon-text">
      <span class="icon">
        <i class="fas fa-tag"></i>
      </span>
      <span>linux</span>
    </span>
  </a>
  
  <a class="has-text-info-dark has-text-weight-semibold" href="https://lymslive.github.io/tags/make/">
    <span class="icon-text">
      <span class="icon">
        <i class="fas fa-tag"></i>
      </span>
      <span>make</span>
    </span>
  </a>
  
</p>

              
            </div>
          </div>
          <div class="content mt-2" id="article-content">
            <!-- # 浅谈 GNU Make 构建项目实践 -->
<h2 id="zhai-yao">摘要</h2>
<p>本文简明地介绍 <code>make</code> 的基础原理，并组合实际项目经验，由浅入深讨论了一种实用
的 <code>makefile</code> 通用规则与模板的编写方案。对其中涉及的语法功能技巧择要阐述，希望
有助于初学者理解。</p>
<span id="continue-reading"></span><h2 id="make-yuan-li-jian-jie">make 原理简介</h2>
<p><code>make</code> 是 linux/unix 系统下的一款工具，就如同 <code>ls/cp/find/grep</code> 这类程序一样属
于基础、通用且经典的设施。其基本原理是根据目标文件与依赖文件的（时间戳）新旧关
系，如果依赖文件更新了（目标文件更旧了），就执行指定的一系列操作。因此它需要这
两部分关键信息，或按 make 的术语叫“规则”：</p>
<ul>
<li>哪个目标文件，会依赖哪些目标文件</li>
<li>满足条件后要执行什么样的操作</li>
</ul>
<p>用户需要将这些规则写入配置文件，以指示 <code>make</code> 的运行，习惯上取名为 <code>makefile</code>
或 <code>Makefie</code> ，也可取为其他名字，那就需要额外加上 <code>-f</code> 选项，如：</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">make
</span><span style="color:#bf616a;">make -f</span><span> filename_other_than_makefile
</span></code></pre>
<p>一个简单的 <code>makefile</code> 规则内容如下：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">oldfile</span><span>: </span><span style="color:#a3be8c;">newfile
</span><span>	</span><span style="color:#96b5b4;">echo</span><span> Hello World
</span><span style="background-color:#bf616a;color:#2b303b;">    </span><span>echo &#39;cp newfile oldfile&#39; &gt;&gt; make.log
</span><span style="background-color:#bf616a;color:#2b303b;">    </span><span>cp newfile oldfile
</span></code></pre>
<p>这里假设 <code>makefile</code> 文件所在目录中另有两个文件名为 <code>oldfile</code> 与 <code>newfile</code> ，只
要在该目录下执行 <code>make</code> 命令，<code>make</code> 程序就会比较这两个文件的时间戳，如果
<code>newfile</code> 更新了，就会将其复制到 <code>oldfile</code> （作为备份之用？），如果没有更新就
不会有任何操作。</p>
<p>可以配置多条操作，凡能在 shell 命令行执行的操作都行。每操作配置需要缩进一个
<code>TAB</code> 键，目标与依赖文件不能缩进，用一个 <code>:</code> 分隔。这就是 <code>makefile</code> 文件的基
本格式要求，当然还有其他许多语法细节，诸如变量引用、变量替换函数、目标依赖链、
隐式规则等，那就不是本文所能细说的了，请参考其他入门教程以及官方手册。</p>
<h2 id="jian-dan-c-cheng-xu-de-gou-jian">简单 C 程序的构建</h2>
<p>虽然可以花式操作用 <code>make</code> 做些奇怪的事，但 <code>make</code> 的主要用途是构建 C/C++ 程序
。一般地，从 C/C++ 源文件到最终可执行程序要经过预处理、编译、链接等多步流程，
<code>make</code> 就是为简化这种构建流程而诞生的。</p>
<h3 id="dan-wen-jian-cheng-xu">单文件程序</h3>
<p>先看个最简单的情况，假设只有一个 <code>main.c</code> 文件，那么 <code>makefile</code> 可如下写法：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">main.exe</span><span>: </span><span style="color:#a3be8c;">main.o
</span><span>	</span><span style="color:#bf616a;">gcc -o</span><span> main.exe main.o
</span><span>
</span><span style="color:#8fa1b3;">main.o</span><span>: </span><span style="color:#a3be8c;">main.c
</span><span>	</span><span style="color:#bf616a;">gcc -c -o</span><span> main.o main.c
</span></code></pre>
<p>这规则文件表明，<code>main.exe</code> 文件依赖 <code>main.o</code> ，而 <code>main.o</code> 又依赖 <code>main.c</code> 。
于是若执行 <code>make</code> 命令，就相当于依次执行如下两条命令：</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">gcc -c -o</span><span> main.o main.c
</span><span style="color:#bf616a;">gcc -o</span><span> main.exe main.o
</span></code></pre>
<p>结果会生成 <code>main.exe</code> 可执行文件，当然在 linux 系统下可执行文件不须也不推荐加
上 <code>.exe</code> 后缀名，此只为说明方便起见。</p>
<p>另外，<code>gcc</code> 编译器有很多默认行为，可直接执行 <code>gcc -c main.c</code> 生成默认 <code>main.o</code>
的目标文件，不必加 <code>-o</code> 选项。甚至直接 <code>gcc main.c</code> 一步到位，自动预处理、编译
、链接成可执行文件，不过若无 <code>-o</code> 指定输出文件名，默认生成的是 <code>a.out</code> 。</p>
<p>正因为构建 C/C++ 程序是 <code>make</code> 的拿手好戏，它专门为此默认了一些隐式规则，以简化
<code>makefile</code> 的编写，比如 <code>*.o</code> 目标文件的依赖与生成规则就可以省略。简化为一条规
则：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">main.exe</span><span>: </span><span style="color:#a3be8c;">main.o
</span><span>	</span><span style="color:#bf616a;">gcc -o</span><span> main.exe main.o
</span></code></pre>
<h3 id="duo-wen-jian-cheng-xu">多文件程序</h3>
<p>当然对于单文件程序的编绎，没必要写 <code>makefie</code> ，直接 <code>gcc -o main.exe main.c</code>
一条命令解决问题。但假如有多个文件，除 <code>main.c</code> 外，还有两个额外的辅助源文件
<code>util1.c</code> <code>util2.c</code> （及相应的 <code>.h</code> 头文件）。这时直接一条命令虽然也能完成编译
链接工作：</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">gcc -o</span><span> main.exe *.c
</span></code></pre>
<p>但有个问题，只要改了一个源文件，就要重新编译所有源文件。所以 <code>make</code> 就有用了，
可写个 <code>makefile</code> 如下：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#bf616a;">TARGET </span><span>= </span><span style="color:#a3be8c;">main.exe
</span><span style="color:#bf616a;">ALL_OBJ </span><span>= </span><span style="color:#a3be8c;">main.o util1.o util2.o
</span><span>
</span><span style="color:#bf616a;">CFLAGS </span><span>+= </span><span style="color:#a3be8c;">-Wall 
</span><span>
</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TARGET</span><span style="color:#b48ead;">) </span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">ALL_OBJ</span><span style="color:#b48ead;">)
</span><span>	</span><span style="color:#bf616a;">gcc </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CFLAGS</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;"> -o </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TARGET</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">ALL_OBJ</span><span style="color:#b48ead;">)
</span></code></pre>
<p>这里用到了变量，语法类似 shell ，不过引用变量要加括号 <code>$(VAR_NAME)</code> 。也省略了
从 <code>.c</code> 到 <code>.o</code> 的编译规则，但按 <code>make</code> 的隐式规则，也会自动编译生成三个 <code>.o</code>
中间文件。如果后来修改了一个 <code>.c</code> 文件，则 <code>make</code> 只会重新编译一个 <code>.o</code> 文件，
另外两个目标不用重新编译，然后将新编译 <code>.o</code> 文件与原来无改动的 <code>.o</code> 文件一起链
接生成新的 <code>main.exe</code> 最终可执行文件。</p>
<p><code>make</code> 命令可以加参数的，参数就是所用 <code>makefile</code> 内定义的目标（文件）名，默认
是文件内定义的第一个目标。假如在开发中改过 <code>util1.c</code> 文件，只是暂时想
检查一下语法有没错误，可以明确提供目标参数：</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#c0c5ce;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#bf616a;">make</span><span> util1.o
</span></code></pre>
<p>这里的 <code>util1.o</code> 能由隐式规则生成，故而也是可用的。这比直接在命令行写
<code>gcc -c util1.c</code> 的优势是可在 <code>makefile</code> 定义一系列编译选项，避免记不住或每次
输入麻烦的问题。</p>
<h3 id="tou-wen-jian-bao-han-yi-lai-chu-li">头文件包含依赖处理</h3>
<p>前述的三文件例程，还漏了重要一点，没加入头文件依赖。最终可执行 <code>main.exe</code> 只依
赖几个 <code>.o</code> 文件，而每个 <code>.o</code> 文件只依赖对应的 <code>.c</code> 文件，在上个 <code>makefile</code> 规
则中完全没有 <code>.h</code> 文件什么事儿。于是如果改动了某个头文件，再执行 <code>make</code> 是没有
作何故事发生的，因为没哪个 <code>.c</code> 文件比它的 <code>.o</code> 更新，<code>make</code> 认为不需要执行任
何操作。这不能甩锅给 <code>make</code> ，是我们没把规则需求给 <code>make</code> 讲明白。</p>
<p>加入头文件 <code>makefile</code> 可修改如下：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#bf616a;">TARGET </span><span>= </span><span style="color:#a3be8c;">main.exe
</span><span style="color:#bf616a;">ALL_OBJ </span><span>= </span><span style="color:#a3be8c;">main.o util1.o util2.o
</span><span>
</span><span style="color:#bf616a;">CFLAGS </span><span>+= </span><span style="color:#a3be8c;">-Wall 
</span><span>
</span><span style="color:#8fa1b3;">.PHONY</span><span>: </span><span style="color:#a3be8c;">all
</span><span style="color:#8fa1b3;">all</span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TARGET</span><span style="color:#b48ead;">)
</span><span>
</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TARGET</span><span style="color:#b48ead;">) </span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">ALL_OBJ</span><span style="color:#b48ead;">)
</span><span>	</span><span style="color:#bf616a;">gcc </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CFLAGS</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;"> -o </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TARGET</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">ALL_OBJ</span><span style="color:#b48ead;">)
</span><span>
</span><span style="color:#8fa1b3;">util1.o</span><span>: </span><span style="color:#a3be8c;">util1.c util1.h
</span><span>	</span><span style="color:#bf616a;">gcc </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CFLAGS</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;"> -o $@ $^
</span><span>
</span><span style="color:#8fa1b3;">util2.o</span><span>: </span><span style="color:#a3be8c;">util2.c util2.h util1.h
</span><span>	</span><span style="color:#bf616a;">gcc </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CFLAGS</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;"> -o $@ $^
</span><span>
</span><span style="color:#8fa1b3;">main.o</span><span>: </span><span style="color:#a3be8c;">main.c util1.h util2.h
</span><span>	</span><span style="color:#bf616a;">gcc </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CFLAGS</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;"> -o $@ $^
</span></code></pre>
<p>将每个 <code>.o</code> 目标文件所依赖的源文件及其头文件明确列出，注意一个源文件经常是会交
叉包含其他头文件的。这些规则添加在 <code>makefile</code> 末尾没有问题，因为 <code>make</code> 会先读
入整个 <code>makefile</code> 文件，扫描解析后定出依赖链，定出变量的最终值。再顺便解释几个
新元素：</p>
<ul>
<li><code>$@</code> 在规则下的操作命令中代表目标文件</li>
<li><code>$^</code> 在规则下的操作命令中代表第一个依赖文件，这有利于简化书写及规则通用化</li>
<li><code>.PHONY: all</code> 明确指出 <code>all</code> 为伪规则，否则当目录中正好有个名为 <code>all</code> 的文件
时，会触发 <code>make</code> 去读它的时间戳。习惯上常将 <code>all</code> 当作第一个默认目标。</li>
</ul>
<p>这虽然正确地解决了问题，但很容易想到一旦程序源文件多起来，如此手动地指出每个目
标文件所依赖的头文件太繁琐易错了。<code>make</code> 不会这么愚蠢，肯定有更机智的办法。这
就需要预处理器的功能了，之前一直忽略了这个流程，也因为平时少用到。</p>
<p>预处理器 <code>cpp</code> （这是英文缩写，与 C++ 的后缀名正好犯冲，但完全是两个东西）一个
重要功能是展开宏，生成真正的源文件供给编译器。如果看不懂复杂宏技巧，可将 <code>cpp</code>
处理的中间文件保存下来分析，不过这是另一个话题了。但是 <code>cpp</code> 预处理时肯定要读
取每个被包含的头文件，它肯定能掌握被处理源文件所需依赖哪些头文件信息，只要将这
部分信息保存下来，就能为 <code>make</code> 所用了。</p>
<p>通过手册 <code>man cpp</code> 或搜索教程，就能找到使用 <code>-M</code> 选项正是输出目标文件依赖规则
的功能。例如 <code>cpp -M main.c</code> 可能是如下输出：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>main.o: main.c util1.h uti2.h \
</span><span> /usr/include/stdio.h \
</span><span># ... 以下省略更多
</span></code></pre>
<p>显然，这与我们手写的目标文件依赖规则很像，只是可能更长得多，因为它必然还依赖某
些标准库头文件。如果一行显示不全，可能分行显示，但需要在上行开尾加 <code>\</code> 转义掉
换行符，使其逻辑上等效于写在一长行中。</p>
<p>如果用 <code>-MM</code> 选项代替 <code>-M</code> 选项，则不会输出那些在 <code>/usr/include/</code> 等标准目录下
的依赖头文件，这更适合于 <code>make</code> 使用。毕竟正常开发者不会也无权限去修改标准库的
头文件吧。此外，<code>cpp</code> 是在运行在标准输入与标准输出的，如果想保存为文件得重定向
。</p>
<p>现在，我们可以祭出 <code>cpp</code> 来优化 <code>makefile</code> 的编写方式了：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#bf616a;">TARGET </span><span>= </span><span style="color:#a3be8c;">main.exe
</span><span style="color:#bf616a;">SRC_DIR </span><span>= </span><span style="color:#a3be8c;">.
</span><span style="color:#bf616a;">ALL_SRC </span><span>= </span><span style="color:#b48ead;">$(</span><span style="color:#96b5b4;">wildcard </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SRC_DIR:%=%/*.c</span><span style="color:#b48ead;">)) </span><span style="color:#65737e;"># 自动获取所有 .c 源文件
</span><span style="color:#bf616a;">ALL_OBJ </span><span>= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">ALL_SRC:%.c=%.o</span><span style="color:#b48ead;">) </span><span style="color:#65737e;"># 替换 .c 后缀为 .o 得到所有目标文件列表
</span><span style="color:#bf616a;">ALL_DEP </span><span>= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">ALL_SRC:%.c=%.d</span><span style="color:#b48ead;">) </span><span style="color:#65737e;"># 得到一系列 .d 依赖文件列表
</span><span>
</span><span style="color:#bf616a;">CFLAGS </span><span>+= </span><span style="color:#a3be8c;">-Wall 
</span><span>
</span><span style="color:#8fa1b3;">.PHONY</span><span>: </span><span style="color:#a3be8c;">all clean
</span><span style="color:#8fa1b3;">all</span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TARGET</span><span style="color:#b48ead;">)
</span><span style="color:#8fa1b3;">clean</span><span>:
</span><span>	</span><span style="color:#bf616a;">rm -rf </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TARGET</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">ALL_OBJ</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">ALL_DEP</span><span style="color:#b48ead;">)
</span><span>
</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TARGET</span><span style="color:#b48ead;">) </span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">ALL_OBJ</span><span style="color:#b48ead;">)
</span><span>	</span><span style="color:#bf616a;">gcc </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CFLAGS</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;"> -o </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TARGET</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">ALL_OBJ</span><span style="color:#b48ead;">)
</span><span>
</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">ALL_DEP</span><span style="color:#b48ead;">)</span><span>: </span><span style="color:#bf616a;">%</span><span style="color:#a3be8c;">.d : </span><span style="color:#bf616a;">%</span><span style="color:#a3be8c;">.c </span><span style="color:#65737e;"># 用 cpp 处理每个 .c ，保存 .d 依赖文件
</span><span>	</span><span style="color:#bf616a;">cpp -MM $&lt; </span><span>&gt; </span><span style="color:#bf616a;">$@
</span><span>
</span><span style="color:#b48ead;">ifneq </span><span>(</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">MAKECMDGOALS</span><span style="color:#b48ead;">)</span><span>, clean)
</span><span style="color:#b48ead;">-include $(</span><span style="color:#bf616a;">ALL_DEP</span><span style="color:#b48ead;">) </span><span style="color:#65737e;"># 将所有 .d 文件包含进来，实现目标文件的依赖规则
</span><span style="color:#b48ead;">endif
</span></code></pre>
<p>关键新行已添加注释（<code>makefile</code> 注释语法与 <code>bash</code> 一样使用 <code>#</code>）。我们先用
<code>wildcard</code> 函数提取 <code>SRC_DIR</code> 源码目录（这里是当前目录 <code>.</code>）下所有 <code>.c</code> 文件，
这就不限于之前的三个源文件的小程序了。得到 <code>ALL_SRC</code> 是一长串以空格分隔的
源文件名列表，然后用变量替换功能转换一长串 <code>.o</code> 目标文件名存为 <code>ALL_OBJ</code> ，以
及 <code>ALL_DEP</code> 一长串 <code>.d</code> 文件名，不妨称之为依赖文件。</p>
<p>每个依赖文件用 <code>cpp -MM</code> 命令生成，并且可只用一条通配规则 <code>%.d : %.c</code> 生成，避
免手动书写重复的相似规则。最后关键是，生成的 <code>.d</code> 文件可用 <code>include</code> 命令包含
进来，因为每个 <code>.d</code> 文件也是符合 <code>makefile</code> 语法规则的。<code>-include</code> 加个 <code>-</code> 前
缀是忽略错误之义，写在 <code>ifneq</code> 与 <code>endif</code> 之间只是锦上添花并非必须，这可避免在
执行 <code>make clean</code> 时把 <code>.d</code> 文件包含进来，因为那没意义了。</p>
<p>注意这里还是利用了生成目标文件的隐式规则。包含进来的 <code>.d</code> 文件，声明了类似
<code>%.o : %.c {with list of *.h}</code> 的依赖规则，但没有写明操作命令，<code>make</code> 有隐式规
则会从相同目录下的 <code>.c</code> 文件生成所需的 <code>.o</code> ，也能自动添加约定的 <code>CFLAGS</code> 选项
参数。其实也可显式添加一条通配规则，并未增加太多复杂度：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">ALL_OBJ</span><span style="color:#b48ead;">)</span><span>: </span><span style="color:#bf616a;">%</span><span style="color:#a3be8c;">.o : </span><span style="color:#bf616a;">%</span><span style="color:#a3be8c;">.c
</span><span>	</span><span style="color:#bf616a;">gcc -c </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CFLAGS</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;"> -o $@ $&lt;
</span></code></pre>
<h2 id="fu-za-xiang-mu-gong-cheng-de-gou-jian">复杂项目工程的构建</h2>
<p>在上节讨论中，我们给出了一个几乎通用的 <code>makefile</code> 文件，内中完全没有写死哪个源
文件或目标文件。但它还是有些问题。首先它仍假设所有源文件在一个目录，需要进入那
个目录使之成为当前目录执行 <code>make</code> ，而且所有目标文件与依赖文件这些临时的中间文
件也都与源文件混在一起，污染视听。另一个小问题是它只用于构建 C 程序，而现在
C++ 程序似乎更主流，当然这改起来也简便。</p>
<h3 id="dian-xing-shi-ji-gong-cheng-xiang-mu-de-mu-lu-jie-gou">典型实际工程项目的目录结构</h3>
<p>在实践中，一个工程项目的目录结构其实是个设计问题，不一定有严格标准。但多少也有
些相似的共识习惯，至少肯定是有多个目录的层次结构，不会是单目录一把梭。</p>
<p>例如一个大项目可能是如下组织：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>/path/to/project/root/macro_service
</span><span>    doc/
</span><span>    config/
</span><span>    src/
</span><span>        model1/
</span><span>        model2/
</span><span>        ......
</span><span>    include/
</span><span>    lib/
</span><span>    obj/
</span></code></pre>
<p>主要就是将源代码放在 <code>src/</code> 目录下，并且由于源文件数量太多，还应该分模块子目录
存放。与 <code>src/</code> 平级可能有些辅助目录，很可能希望将编译中间文件从 <code>src/</code> 分离，
统一放在平级的 <code>obj/</code> 目录下。</p>
<p>现在互联网据说较为流行微服务。那么它一个项目要编译的就不只一个大程序了，可能是
一组数量较多的可执行程序。也许其目录结构会是这样：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>/path/to/project/root
</span><span>    common1/
</span><span>    util2/
</span><span>    micro_service/
</span><span>        serviceA/
</span><span>        serviceB/
</span><span>            1.cpp 1.hpp 2.cpp 2.hpp ...
</span><span>            may_also_subdir/
</span><span>        serviceC/
</span><span>    third1/
</span><span>    third2/
</span><span>    tools/
</span><span>        toolA/
</span><span>        toolB/
</span><span>    unit-tets/
</span></code></pre>
<p>服务数量众多，但每个服务的代码量不甚巨大，也许几个或几十文件就可实现功能。也因
为服务众多，必然会有些公用代码，正常想法会提到外面共用。如此很可能每个服务用自
己的单个目录就能存放所有源文件了，不必要再加一层 <code>src/</code> ，否则太多 <code>src/</code> 也奇
怪。除了生产服务，可能还有命令行工具程序及单元测试，理论上这或许可用脚本完成任
务，但既然是熟悉 C/C++ 的团队，又在有较完善的公共库的情况下，直接用 C/C++ 也更
和谐。此外可能直接下载使用一些第三方开源库，不想安装在系统中，直接扔在项目中了
。如果三方库或自研库数量多起来，或许还要继续分别加层目录管理。</p>
<p>本文拟基于后一种微服务集的工程目录结构假设，说明以 <code>make</code> 构建项目的流程模式。
因为如果一个微服务内的源码也有再分子目录的话，那就与一个大服务的编译过程没有质
的区别了，只是量（编译时间）的差异了。</p>
<h3 id="makefile-mo-ban-yu-include">makefile 模板与 include</h3>
<p>现在需求是在许多子目录中编译出可执行程序。显然在每个这样的源码目录中写一份完整
的 <code>makefile</code> 略显笨拙，尽管可以将上节所述的通用 <code>makefile</code> 复制到每个需要编译
的目录中。更好的办法是将那个通用的 <code>makefile</code> 放在项目根目录中，比如取名为
<code>root.mk</code> ，然后在每个编译目录中的 <code>makefile</code> 中 <code>include</code> 它。</p>
<p>然后再梳理一下，在每个具体的 <code>makefile</code> 中，还需要提供哪些额外信息呢。将这些信
息以变量配置的方式写下来。大体框架可能如下：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#bf616a;">TYPE		</span><span>= </span><span style="color:#a3be8c;">exe
</span><span style="color:#bf616a;">TARGET		</span><span>= </span><span style="color:#a3be8c;">a.out
</span><span style="color:#bf616a;">INSTALL_DIR	</span><span>= </span><span style="color:#a3be8c;">/path/to/install/
</span><span style="color:#bf616a;">SRC_DIR		</span><span>= </span><span style="color:#a3be8c;">. sub1 sub2
</span><span style="color:#bf616a;">OBJ_DIR		</span><span>=
</span><span style="color:#bf616a;">INC_DIR		</span><span>= 
</span><span style="color:#bf616a;">LIB_DIR		</span><span>= 
</span><span style="color:#bf616a;">SYS_LIB		</span><span>=
</span><span style="color:#bf616a;">LIB_DEPENDS	</span><span>= 
</span><span style="color:#bf616a;">OBJ_DEPENDS	</span><span>= 
</span><span style="color:#bf616a;">EXTRA_CFLAGS	</span><span>=
</span><span style="color:#bf616a;">EXTRA_CXXFLAGS	</span><span>=
</span><span style="color:#b48ead;">include </span><span style="color:#a3be8c;">../../root.mk
</span></code></pre>
<p>主要是用变量定义一些必要信息，且大部分若接受默认值的话可留为空串：</p>
<ul>
<li>最终目录目标 <code>TARGET</code> 及其类型 <code>TYPE</code> ，比如是可执行程序还是打包的静态链接库
或动态链接库等。</li>
<li>列出源码目录 <code>SRC_DIR</code> ，相对这个 <code>makefile</code> 文件的路径，
如果有太多子目及深层子目录，可利用相关功能函数生成目录列表串。</li>
<li>编译中间文件的存放目录 <code>OBJ_DIR</code> ，希望与 <code>SRC_DIR</code> 分开。</li>
<li>头文件所在目录（非标准目录），将来要用于 <code>-I</code> 选项的。</li>
<li>所需用到的链接库与链接目录，将来用于 <code>-L</code> 与 <code>-l</code> 选项的。</li>
<li>所需本项目内预编译的其他公共依赖库 <code>OBJ_DEPENDS</code> 。</li>
<li>额外的 <code>gcc</code> 或 <code>g++</code> 编译选项。</li>
<li>最后是以相对路径引用项目根目录的通用规则文件。</li>
</ul>
<h3 id="tong-yong-makefile-gui-ze-zai-you-hua">通用 makefile 规则再优化</h3>
<p>通用 <code>root.mk</code> 大约可分为几部分。首先是处理变量：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#bf616a;">TARGET  </span><span>:= </span><span style="color:#b48ead;">$(</span><span style="color:#96b5b4;">strip </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TARGET</span><span style="color:#b48ead;">))
</span><span style="color:#bf616a;">TYPE    </span><span>:= </span><span style="color:#b48ead;">$(</span><span style="color:#96b5b4;">strip </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TYPE</span><span style="color:#b48ead;">))
</span><span style="color:#bf616a;">INSTALL_DIR </span><span>:= </span><span style="color:#b48ead;">$(</span><span style="color:#96b5b4;">strip </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">INSTALL_DIR</span><span style="color:#b48ead;">))
</span><span style="color:#bf616a;">CC       </span><span>= </span><span style="color:#a3be8c;">gcc
</span><span style="color:#bf616a;">CXX      </span><span>= </span><span style="color:#a3be8c;">g++
</span><span style="color:#bf616a;">CPP      </span><span>= </span><span style="color:#a3be8c;">cpp
</span><span style="color:#bf616a;">CFLAGS   </span><span>+= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">C_INC</span><span style="color:#b48ead;">)
</span><span style="color:#bf616a;">CXXFLAGS </span><span>+= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">C_INC</span><span style="color:#b48ead;">)
</span><span style="color:#bf616a;">CFLAGS	 </span><span>+= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">EXTRA_CFLAGS</span><span style="color:#b48ead;">)
</span><span style="color:#bf616a;">CXXFLAGS </span><span>+= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">EXTRA_CXXFLAGS</span><span style="color:#b48ead;">)
</span><span>
</span><span style="color:#bf616a;">CFLAGS	 </span><span>+= </span><span style="color:#a3be8c;">-Wall
</span><span style="color:#bf616a;">CXXFLAGS </span><span>+= </span><span style="color:#a3be8c;">-Wall
</span><span style="color:#bf616a;">EXTRA_CXXFLAGS </span><span>+= </span><span style="color:#a3be8c;">-std=c++11
</span><span>
</span><span style="color:#bf616a;">SRC_DIR  </span><span>+= </span><span style="color:#a3be8c;">.
</span><span style="color:#bf616a;">OBJ_DIR  </span><span>?= </span><span style="color:#a3be8c;">obj/
</span><span style="color:#bf616a;">INC_DIR  </span><span>+= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">COMM_INC_DIR</span><span style="color:#b48ead;">)
</span><span style="color:#bf616a;">INC_DIR  </span><span>+= </span><span style="color:#a3be8c;">/usr/include/mysql/ /usr/include/ ../ ./ ../../
</span><span style="color:#bf616a;">SYS_LIB  </span><span>+= </span><span style="color:#a3be8c;">libpthread libcurl libmysqlclient </span><span style="color:#65737e;"># and more needed
</span><span style="color:#bf616a;">LIB_DIR  </span><span>+= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">COMM_LIB_DIR</span><span style="color:#b48ead;">)
</span><span style="color:#bf616a;">LIB_DIR  </span><span>+= </span><span style="color:#a3be8c;">/usr/lib/ /usr/lib64/ /usr/lib64/mysql/
</span><span style="color:#bf616a;">C_INC    </span><span>= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">INC_DIR:%=-I%</span><span style="color:#b48ead;">)
</span><span style="color:#bf616a;">C_LIB    </span><span>= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">LIB_DIR:%=-L%</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">LIB_DEPENDS:lib%=-l%</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">SYS_LIB:lib%=-l%</span><span style="color:#b48ead;">)
</span></code></pre>
<p>这里将编译器名 <code>gcc</code> 或 <code>g++</code> 也赋给变量，万一以后要改用 <code>clang</code> 编译，也只要
改一处。<code>makefile</code> 的变量赋值涉及几种等号，简单解释一下。</p>
<ul>
<li><code>=</code> 常规的等号，如果右边引用了其他变量，则会递归解析，扫描完全文才能最终确定
变量值。例如 <code>CFLAGS</code> 变量先定义包含了 <code>C_INC</code> ，后边 <code>C_INC</code> 再由 <code>INC_DIR</code>
定义变换而来。</li>
<li><code>:=</code> 一次解析当前变量值，等号右的引用的变量后面变化了也不影响左边的变量值。</li>
<li><code>?=</code> 只有当左边的变量未定义时赋值（空串值也算定义过，不会发生赋值）。例如
<code>OBJ_DIR</code> 默认设为 <code>obj/</code> ，但如果（某个具体子目录内的 <code>makefile</code> 配置）定义
了 <code>OBJ_DIR</code> 就使用原配置，空值就表示目标文件将与源文件混在同一目录。</li>
</ul>
<p>这部分主要是变量值转换处理，准备好编译器命令的选项参数等。接下来是编译源文件为
目标文件的规则：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#bf616a;">C_SRC   </span><span>= </span><span style="color:#b48ead;">$(</span><span style="color:#96b5b4;">wildcard </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SRC_DIR:%=%/*.c</span><span style="color:#b48ead;">))
</span><span style="color:#bf616a;">CXX_SRC </span><span>= </span><span style="color:#b48ead;">$(</span><span style="color:#96b5b4;">wildcard </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">SRC_DIR:%=%/*.cpp</span><span style="color:#b48ead;">))
</span><span style="color:#bf616a;">C_OBJ   </span><span>= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">C_SRC:%.c=</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">OBJ_DIR</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;">%.o</span><span style="color:#b48ead;">)
</span><span style="color:#bf616a;">CXX_OBJ </span><span>= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CXX_SRC:%.cpp=</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">OBJ_DIR</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;">%.o</span><span style="color:#b48ead;">)
</span><span style="color:#bf616a;">C_DEP   </span><span>= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">C_SRC:%.c=</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">OBJ_DIR</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;">%.d</span><span style="color:#b48ead;">)
</span><span style="color:#bf616a;">CXX_DEP </span><span>= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CXX_SRC:%.cpp=</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">OBJ_DIR</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;">%.d</span><span style="color:#b48ead;">)
</span><span>
</span><span style="color:#bf616a;">ALL_OBJ </span><span>= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">C_OBJ</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">CXX_OBJ</span><span style="color:#b48ead;">)
</span><span style="color:#bf616a;">ALL_DEP </span><span>= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">C_DEP</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">CXX_DEP</span><span style="color:#b48ead;">)
</span><span>
</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">C_DEP</span><span style="color:#b48ead;">)</span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">OBJ_DIR</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;">%</span><span style="color:#a3be8c;">.d : </span><span style="color:#bf616a;">%</span><span style="color:#a3be8c;">.c
</span><span>	</span><span style="color:#d08770;">@</span><span style="color:#bf616a;">mkdir -p </span><span style="color:#b48ead;">$(</span><span style="color:#96b5b4;">dir </span><span style="color:#bf616a;">$@</span><span style="color:#b48ead;">)
</span><span>	</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CPP</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">EXTRA_CFLAGS</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">C_INC</span><span style="color:#b48ead;">) </span><span style="color:#bf616a;">-M $&lt; </span><span>&gt; </span><span style="color:#bf616a;">$@
</span><span style="background-color:#bf616a;color:#2b303b;">    </span><span style="color:#d08770;">@</span><span>sed -r -i &#39;s|^(\w+)\.o[ :]*|$(@:.d=.o) : |&#39; $@
</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CXX_DEP</span><span style="color:#b48ead;">)</span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">OBJ_DIR</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;">%</span><span style="color:#a3be8c;">.d : </span><span style="color:#bf616a;">%</span><span style="color:#a3be8c;">.cpp
</span><span>	</span><span style="color:#d08770;">@</span><span style="color:#bf616a;">mkdir -p </span><span style="color:#b48ead;">$(</span><span style="color:#96b5b4;">dir </span><span style="color:#bf616a;">$@</span><span style="color:#b48ead;">)
</span><span>	</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CPP</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">EXTRA_CXXFLAGS</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">C_INC</span><span style="color:#b48ead;">) </span><span style="color:#bf616a;">-MM $&lt; </span><span>&gt; </span><span style="color:#bf616a;">$@
</span><span>	</span><span style="color:#d08770;">@</span><span style="color:#bf616a;">sed -r -i </span><span>&#39;</span><span style="color:#a3be8c;">s|^(</span><span style="color:#96b5b4;">\w</span><span style="color:#a3be8c;">+)</span><span style="color:#96b5b4;">\.</span><span style="color:#a3be8c;">o[ :]*|</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">@:.d=.o</span><span style="color:#b48ead;">)</span><span style="color:#a3be8c;"> : |</span><span>&#39; </span><span style="color:#bf616a;">$@
</span><span>
</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">C_OBJ</span><span style="color:#b48ead;">)</span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">OBJ_DIR</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;">%</span><span style="color:#a3be8c;">.o : </span><span style="color:#bf616a;">%</span><span style="color:#a3be8c;">.c
</span><span>	</span><span style="color:#d08770;">@</span><span style="color:#bf616a;">mkdir -p </span><span style="color:#b48ead;">$(</span><span style="color:#96b5b4;">dir </span><span style="color:#bf616a;">$@</span><span style="color:#b48ead;">)
</span><span>	</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CC</span><span style="color:#b48ead;">) </span><span style="color:#bf616a;">-c </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CFLAGS</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">EXTRA_CFLAGS</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;"> -o $@ $&lt;
</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CXX_OBJ</span><span style="color:#b48ead;">)</span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">OBJ_DIR</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;">%</span><span style="color:#a3be8c;">.o : </span><span style="color:#bf616a;">%</span><span style="color:#a3be8c;">.cpp
</span><span>	</span><span style="color:#d08770;">@</span><span style="color:#bf616a;">mkdir -p </span><span style="color:#b48ead;">$(</span><span style="color:#96b5b4;">dir </span><span style="color:#bf616a;">$@</span><span style="color:#b48ead;">)
</span><span>	</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CXX</span><span style="color:#b48ead;">) </span><span style="color:#bf616a;">-c </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CXXFLAGS</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">EXTRA_CXXFLAGS</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;"> -o $@ $&lt;
</span><span>
</span><span style="color:#b48ead;">ifneq </span><span>(</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">MAKECMDGOALS</span><span style="color:#b48ead;">)</span><span>, clean)
</span><span style="color:#b48ead;">-include $(</span><span style="color:#bf616a;">ALL_DEP</span><span style="color:#b48ead;">)
</span><span style="color:#b48ead;">endif
</span></code></pre>
<p>这里为了同时处理 C 与 C++ 源文件，分别定义了 <code>C_SRC</code> 与 <code>CXX_SRC</code> 保存所有匹配
的源文件列表，并分别转换获取 <code>C_OBJ</code> 与 <code>CXX_OBJ</code> ，最后拼接成所有目标文件
<code>ALL_OBJ</code> ，同理 <code>ALL_DEP</code> 保存所有 <code>.d</code> 文件列表。这只是平行地写了两套变量，
增加的一倍代码量属于线性复杂度而已。如果项目中有的 C++ 源文件还会用到 <code>.cc</code> 或
<code>.C</code> （大写C）后缀名，可考虑再平行写一套类似 <code>CCC_SRC</code> <code>CCC_OBJ</code> <code>CCC_DEP</code> 的
变量名；如果觉得这太冗余，有失美观，可以的话将 C++ 源文件后缀名批量统一改为
<code>.cpp</code> 吧。</p>
<p>与上节末的 <code>makefile</code> 文件相比，这段代码还将所有 <code>*.o</code> 与 <code>*.d</code> 中间文件放在
<code>OBJ_DIR</code> 目录下（个人觉得不必要再将中间文件分门别类放入不同的目录，所以只定义
了一个 <code>OBJ_DRI</code>）。但这会遭遇另一个问题，<code>cpp -MM</code> 的输出，不会包含目标文件
<code>.o</code> 的目录信息，只取基础文件名。这里的解决办法是用 <code>sed</code> 再处理生成的 <code>.d</code>
文件。</p>
<p><code>sed</code> 的 <code>-r</code> 选项表示使用扩展的正则表达式，影响后面的正则表达式写法。常规正则
替换写法是 <code>s/exp/rep/</code> ，不过处理文件名时很可能用到 <code>/</code> ，于是改用 <code>s|reg|rep|</code> 
竖线分隔符更方便些。<code>-i</code> 表示原位修改文件，开始不确定时可以多写一步中间文件尝
试下：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CXX_DEP</span><span style="color:#b48ead;">)</span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">OBJ_DIR</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;">%</span><span style="color:#a3be8c;">.d : </span><span style="color:#bf616a;">%</span><span style="color:#a3be8c;">.cpp
</span><span>	</span><span style="color:#bf616a;">mkdir -p </span><span style="color:#b48ead;">$(</span><span style="color:#96b5b4;">dir </span><span style="color:#bf616a;">$@</span><span style="color:#b48ead;">)
</span><span>	</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CPP</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">EXTRA_CXXFLAGS</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">C_INC</span><span style="color:#b48ead;">) </span><span style="color:#bf616a;">-MM $&lt; </span><span>&gt; </span><span style="color:#bf616a;">$@</span><span>.tmp
</span><span>	</span><span style="color:#bf616a;">sed -r </span><span>&#39;</span><span style="color:#a3be8c;">s|^(</span><span style="color:#96b5b4;">\w</span><span style="color:#a3be8c;">+)</span><span style="color:#96b5b4;">\.</span><span style="color:#a3be8c;">o[ :]*|</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">@:.d=.o</span><span style="color:#b48ead;">)</span><span style="color:#a3be8c;"> : |</span><span>&#39; &lt; </span><span style="color:#bf616a;">$@</span><span>.tmp &gt; </span><span style="color:#bf616a;">$@
</span><span>	</span><span style="color:#65737e;"># rm $@.tmp
</span></code></pre>
<p>在 <code>makefile</code> 的规则操作行，前导 <code>@</code> 表示不回显执行命令本身。在调教成功后，可
以在 <code>mkdir -p</code> 与 <code>sed -ri</code> 命令前加 <code>@</code> 减少冗余输出。</p>
<p>然后是编译最终目标的部分，根据目标类型编写不同规则：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#bf616a;">TARGET_MAKE </span><span>:= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">OBJ_DIR</span><span style="color:#b48ead;">)$(</span><span style="color:#bf616a;">TARGET</span><span style="color:#b48ead;">)
</span><span style="color:#bf616a;">TARGET_INSTALL </span><span>:= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">INSTALL_DIR</span><span style="color:#b48ead;">)$(</span><span style="color:#bf616a;">TARGET</span><span style="color:#b48ead;">)
</span><span>
</span><span style="color:#b48ead;">ifeq </span><span>(</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TYPE</span><span style="color:#b48ead;">)</span><span>, exe)
</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TARGET_MAKE</span><span style="color:#b48ead;">)</span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">ALL_DEP</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">ALL_OBJ</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">OBJ_DEPENDS</span><span style="color:#b48ead;">)
</span><span>	</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CXX</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">C_LIB</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">ALL_OBJ</span><span style="color:#b48ead;">) </span><span style="color:#bf616a;">-Wl,--start-group </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">OBJ_DEPENDS</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;"> -Wl</span><span>,--end-group </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">LDFLAGS</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;"> -o $@
</span><span style="color:#8fa1b3;">install</span><span>: </span><span style="color:#a3be8c;">all
</span><span>	</span><span style="color:#bf616a;">cp -f </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TARGET_MAKE</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">TARGET_INSTALL</span><span style="color:#b48ead;">)
</span><span style="color:#b48ead;">endif
</span><span>
</span><span style="color:#b48ead;">ifeq </span><span>(</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TYPE</span><span style="color:#b48ead;">)</span><span>, liba)
</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TARGET_MAKE</span><span style="color:#b48ead;">)</span><span>:</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">ALL_DEP</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">ALL_OBJ</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">OBJ_DEPENDS</span><span style="color:#b48ead;">)
</span><span>	</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">AR</span><span style="color:#b48ead;">) </span><span style="color:#bf616a;">r </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TARGET_MAKE</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">ALL_OBJ</span><span style="color:#b48ead;">)
</span><span style="color:#8fa1b3;">install</span><span>:</span><span style="color:#a3be8c;">all
</span><span>	</span><span style="color:#bf616a;">cp -f </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TARGET_MAKE</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">TARGET_INSTALL</span><span style="color:#b48ead;">)
</span><span style="color:#b48ead;">endif
</span><span>
</span><span style="color:#b48ead;">ifeq </span><span>(</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TYPE</span><span style="color:#b48ead;">)</span><span>, libso)
</span><span style="color:#bf616a;">SO_DEPENDS </span><span>= </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">LIB_DEPENDS:%=</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">COMM_LIB_DIR</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;">/%.so</span><span style="color:#b48ead;">)
</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TARGET_MAKE</span><span style="color:#b48ead;">)</span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">ALL_DEP</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">ALL_OBJ</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">OBJ_DEPENDS</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">SO_DEPENDS</span><span style="color:#b48ead;">) 
</span><span>	</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">CXX</span><span style="color:#b48ead;">) </span><span style="color:#bf616a;">-shared -fPIC </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">C_LIB</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">ALL_OBJ</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;"> -Wl</span><span>,--start-group </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">OBJ_DEPENDS</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;"> -Wl</span><span>,--end-group </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">LDFLAGS</span><span style="color:#b48ead;">)</span><span style="color:#bf616a;"> -o $@
</span><span style="color:#8fa1b3;">install</span><span>: </span><span style="color:#a3be8c;">all
</span><span>	</span><span style="color:#bf616a;">cp -f </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TARGET_MAKE</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">TARGET_INSTALL</span><span style="color:#b48ead;">)
</span><span style="color:#b48ead;">endif
</span></code></pre>
<p>这里将 <code>make</code> 出的最终目标文件也暂丢进 <code>OBJ_DIR</code> 目录中，<code>make install</code> 再拷到
<code>INSTALL_DIR</code> 目录中。<code>makefile</code> 的 <code>if/endif</code> 也有 <code>else</code> 分支，但没有类似
<code>else if</code> 的语法，且嵌套的 <code>if/endif</code> 并不能缩进，所以可读性不佳，故而这里直接
将几个 <code>if/edif</code> 平行列出。</p>
<p>在定义目录前缀如 <code>OBJ_DIR</code> <code>INSTALL_DIR</code> 时，最好规则带上 <code>/</code> 后缀，然后在使用
处获取全路径时只有直拼接起来，不必额外多写个 <code>/</code> 。这样的好处是兼容空串目录前
缀，否则使用 <code>$(DIR)/$(FILE_NAME)</code> 时，若目录前缀为空就变成了系统的根目录 <code>/</code>
了，这经常是不期望的。</p>
<p>最后一些非关键部分。我们在这个 <code>makefile</code> 中进行了大量的变量处理，开发中有时不
确定这些变量定义得对不对，那可以加个伪目标，把其中关键变量名都打印出来，可利于
调试：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">.PHONY</span><span>: </span><span style="color:#a3be8c;">all clean install echo
</span><span>
</span><span style="color:#8fa1b3;">all</span><span>:</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TARGET_MAKE</span><span style="color:#b48ead;">)
</span><span>
</span><span style="color:#8fa1b3;">clean</span><span>:
</span><span>	</span><span style="color:#bf616a;">rm -rf </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">ALL_OBJ</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">ALL_DEP</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">TARGET_MAKE</span><span style="color:#b48ead;">)
</span><span>
</span><span style="color:#8fa1b3;">echo</span><span>:
</span><span>    </span><span style="color:#d08770;">@</span><span style="color:#96b5b4;">echo </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">ALL_SRC</span><span style="color:#b48ead;">)
</span><span>    </span><span style="color:#d08770;">@</span><span style="color:#96b5b4;">echo</span><span> mkdir -p </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">OBJ_DIR</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">INSTALL_DIR</span><span style="color:#b48ead;">)
</span><span style="background-color:#bf616a;color:#2b303b;">	</span><span style="color:#d08770;">@</span><span>echo $(CPP) $(EXTRA_CXXFLAGS) $(C_INC)
</span><span style="background-color:#bf616a;color:#2b303b;">	</span><span style="color:#d08770;">@</span><span>echo $(ALL_DEP)
</span><span style="background-color:#bf616a;color:#2b303b;">	</span><span style="color:#d08770;">@</span><span>echo $(CXX) -c $(CXXFLAGS) $(EXTRA_CXXFLAGS)
</span><span style="background-color:#bf616a;color:#2b303b;">	</span><span style="color:#d08770;">@</span><span>echo $(ALL_OBJ)
</span><span style="background-color:#bf616a;color:#2b303b;">	</span><span style="color:#d08770;">@</span><span>echo $(CXX) $(C_LIB) $(ALL_OBJ) -Wl,--start-group $(OBJ_DEPENDS) -Wl,--end-group $(LDFLAGS) -o $(TARGET_MAKE)
</span><span style="background-color:#bf616a;color:#2b303b;">	</span><span style="color:#d08770;">@</span><span>echo $(TARGET) $(TARGET_MAKE) $(TARGET_INSTALL)
</span></code></pre>
<p>伪目标 <code>echo</code> 就是把上面搜索到的源文件，转换的目标文件及依赖文件，用到的编译命令
选项等复制下来，一键打印出来瞧一瞧，大概瞄一眼。<code>make -n</code> 选项也只打印将要执行
的操作而不实际执行，但如果目标已经是新的，不需要操作也不就不会有命令打印出来。</p>
<p>最后提醒一下，<code>all:</code> 目标定义最好移到 <code>makefile</code> 前面，使之成为第一个目标，这
样就可以按默认参数只敲入 <code>make</code> 而无需敲入 <code>make all</code> 了。</p>
<h3 id="gong-cheng-duo-mu-lu-zi-dong-bian-yi">工程多目录自动编译</h3>
<p>如果是开发中修改了项目某个或某几个子目录，只要进入相应的目录执行下 <code>make</code> 就好
了。但如果是重新拉一份项目代码，第一次从头编译时，手动进入每个目录进行 <code>make</code>
那也是繁琐的。这就引出一个需求，从根目录自动进入各个含 <code>makefile</code> 的子目录进行
<code>make</code> ，可以写个脚本做这件事，不过一条 <code>find</code> 命令也能实现基本需求：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>find . -name &#39;makefile&#39; -execdir make clean \;
</span><span>find . -name &#39;makefile&#39; -execdir make \;
</span></code></pre>
<p>如果不想记这串 <code>find</code> 命令，可以在项目根目录也写个 <code>makefile</code> ，将这个命令放在
第一个伪目录下面：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">.PHONY</span><span>: </span><span style="color:#a3be8c;">all
</span><span style="color:#8fa1b3;">all</span><span>:
</span><span>	</span><span style="color:#bf616a;">find</span><span> .</span><span style="color:#bf616a;"> -name </span><span>&#39;</span><span style="color:#a3be8c;">makefile</span><span>&#39;</span><span style="color:#bf616a;"> -execdir</span><span> make </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">MAKECMDGOALS</span><span style="color:#b48ead;">) </span><span style="color:#96b5b4;">\;
</span></code></pre>
<p>不过 <code>find</code> 对于大项目递归搜索可能比较耗时，且会搜索许多不必要的目录。如果对此
介意或想体验一下 <code>make</code> 的其他技巧，也可以使用纯 <code>make</code> 的方式来定制进入哪些子
目录。思路与前面所述的 <code>makefile</code> 配置模板与通用规则 <code>root.mk</code> 类似，不过要写
另一套用于中间目录的 <code>makefile</code> 模板与规则。</p>
<p>先在项目根目录与 <code>root.mk</code> 同级处另写一个 <code>dir.mk</code> 如下：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#8fa1b3;">.PHONY</span><span>: </span><span style="color:#a3be8c;">all clean install </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TARGETS</span><span style="color:#b48ead;">)
</span><span style="color:#8fa1b3;">all clean install </span><span>: </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TARGETS</span><span style="color:#b48ead;">)
</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">TARGETS</span><span style="color:#b48ead;">)</span><span>:
</span><span>	</span><span style="color:#d08770;">@</span><span style="color:#96b5b4;">echo </span><span>&quot;</span><span style="color:#a3be8c;">### make </span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">MAKECMDGOALS</span><span style="color:#b48ead;">)</span><span style="color:#a3be8c;"> in </span><span style="color:#bf616a;">$@</span><span>&quot;
</span><span>	</span><span style="color:#d08770;">@</span><span style="color:#b48ead;">$(</span><span style="color:#bf616a;">MAKE</span><span style="color:#b48ead;">) $(</span><span style="color:#bf616a;">MAKECMDGOALS</span><span style="color:#b48ead;">) </span><span style="color:#bf616a;">-C $@ --no-print-directory
</span><span>	</span><span style="color:#d08770;">@</span><span style="color:#96b5b4;">echo
</span></code></pre>
<p>然后在每一个中间目录与根目录，也即不是需要编译源代码的“叶子”目录，写个简单的
<code>makefile</code> 如下：</p>
<pre data-lang="make" style="background-color:#2b303b;color:#c0c5ce;" class="language-make "><code class="language-make" data-lang="make"><span style="color:#bf616a;">TARGETS </span><span>= </span><span style="color:#a3be8c;">sub1 sub2 sub3
</span><span style="color:#b48ead;">include </span><span style="color:#a3be8c;">../dir.mk
</span></code></pre>
<p>只要将该目录下管理的需要编译的子目录明确列出来，赋给变量 <code>TARGET</code> ，然后将根目
录的 <code>dir.mk</code> 包含进来，就能实现自动编译往下一层的子目录了。虽然需要在每个中间
目录添加这样一个 <code>makefile</code> ，但胜在可精细控制，而且也不算太麻烦吧，毕竟在一个
项目中做出增加一层目录的决策本身，比写这个简单 <code>makefile</code> 的工作量复杂得多。</p>
<h2 id="zai-vim-zhong-li-yong-makefile-kuai-jie-bian-yi">在 Vim 中利用 makefile 快捷编译</h2>
<p>Vimer 党也许会直接在 linux 下编辑代码，所以也希望能利用 <code>make</code> 从 vim 直接调起
编译。这里简单说些思路。</p>
<p>如果只是编译单文件小程序，可以直接定义如下快捷键映射：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#96b5b4;">nnoremap </span><span>&lt;F9&gt; :!gcc </span><span style="color:#b48ead;">%</span><span>&lt;CR&gt;
</span></code></pre>
<p>在编辑一个项目时，如果 vim 当前目录有定义 <code>makefile</code> ，也可以直接使用 <code>:make</code>
编译整个工程项目，且编译错误会呈现在 quickfix 窗口中。如果只是要编译当前编辑中
的源文件，看下有没编译错误之用，则可以输入 <code>:make currnet-filename.o</code> 。不过如
果 <code>makefile</code> 规则中将 <code>.o</code> 文件放到其他目录中，也得输入路径信息，利用 vim 命令
行参数补全或可节省些输入。如果想定义快捷键自动输入当前源文件关联的目标文件，那
可能是有点复杂。例如：</p>
<pre data-lang="vim" style="background-color:#2b303b;color:#c0c5ce;" class="language-vim "><code class="language-vim" data-lang="vim"><span style="color:#96b5b4;">nnoremap </span><span>&lt;F9&gt; :make &lt;C-R&gt;=</span><span style="color:#a3be8c;">&#39;obj/&#39; </span><span style="color:#b48ead;">. </span><span style="color:#8fa1b3;">expand</span><span>(</span><span style="color:#a3be8c;">&#39;%:r&#39;</span><span>) </span><span style="color:#b48ead;">. </span><span style="color:#a3be8c;">&#39;.o&#39;</span><span>&lt;CR&gt;&lt;CR&gt;
</span><span style="color:#96b5b4;">nnoermap </span><span>&lt;S-F9&gt; :make&lt;CR&gt;
</span></code></pre>
<p>这里假设按上节的默认规则，目标文件存在当前目录的 <code>obj/</code> 子目录下。因为这种路径
关系依赖于项目的 <code>makefile</code> 书写，所以这个快捷键映射最好也是作为项目相关的配置
，而不要写在全局的 <code>.vimrc</code> 。比如若用 vim 原生的 Session.vim 保存会话，则可将
项目配置写在 <code>Sessionx.vim</code> 脚本中。</p>
<p>还有个问题，如果 vim 未设置 <code>autochir</code> ，则 vim 当前目录很可能与所编辑的源文件
不在一起，或者说只要当前目录没有 <code>makefile</code> 文件，那 <code>:make</code> 命令还得加上 <code>-C</code>
选项先转到含 <code>makfie</code> 的目录中去。至于如何找到相关联的 <code>makefile</code> 文件所在目录
，可能需要了解 VimL 脚本才能较好地解决这问题，这就不展开了。</p>
<h2 id="zong-jie">总结</h2>
<p><code>make</code> 原理极简，但 <code>makefile</code> 细节不少。当然我们不一定要掌握 <code>make</code> 的所有细
节，需要时查询相关手册。本文讨论打造的 <code>makefile</code> 文件，大致可用于大中型 C/C++
项目的构建了，或许还需根据实际情况调整一些编译选项。<code>make</code> 的实际使用基础，还
是需要对 C/C++ 程序的编译流程与所用编译器提供的选项功能熟悉。不过在掌握更多 
<code>makefile</code> 语法后，可以更有效地优化与控制编译过程。</p>
<p>尽管现在也有许多自动构建工具了，比如 <code>CMake</code> ，能自动生成 <code>makefile</code> 。但由通
用工具生成的 <code>makefile</code> 可读性太复杂。若能理解 <code>make</code> 原理并手写 <code>makefile</code> ，
那会更有成就感与控制感。而且使用 <code>CMake</code> 不也得学习一下 <code>CMakeList.txt</code> 的写法
么。如果没有跨平台编译的需求，只在 <code>linux</code> 下使用的，根据自己的项目定制一份
<code>makefile</code> 模板，那后续使用也是相当简单方便的。</p>
<h2 id="can-kao-lian-jie">参考链接</h2>
<ul>
<li>
<p>http://ruanyifeng.com/blog/2015/02/make.html 阮一峰写的 Make 教程</p>
</li>
<li>
<p>https://blog.codingnow.com/2009/03/gnu_make_vpath.html 云风的博客，其中谈到
<code>vpath</code> 与 <code>cpp -MT</code> 选项，只是我具体没试出怎么用好。</p>
</li>
<li>
<p>https://blog.csdn.net/yufei_email/article/details/78575637 另一篇 CSDN 的博客
，也用的 <code>sed</code> 大法处理 <code>cpp -M</code> 的头文件依赖关系。</p>
</li>
<li>
<p>https://www.gnu.org/software/make/manual/html_node/index.html 官方手册，忘记了
变量与函数用法可以查查。</p>
</li>
</ul>

          </div>
        </article>
      </div>
      
    </div>
  </div>
</section>


  
  <section class="modal" id="search-modal">
    <div class="modal-background"></div>
    <div class="modal-card">
      <header class="modal-card-head">
        <p class="modal-card-title">Search</p>
      </header>
      <section class="modal-card-body">
        <div class="field mb-2">
          <div class="control">
            <input class="input" id="search" placeholder="Search this website." type="search" />
          </div>
        </div>
        <div class="search-results">
          <div class="search-results__items"></div>
        </div>
      </section>
    </div>
    <button aria-label="close" class="modal-close is-large"></button>
  </section>
  


  

<section class="section">
  <div class="container">
    <div class="columns is-centered">
      <div class="column is-8">
        <nav class="level">
              
          <div class="level-item has-text-centered">
            <a class="button is-black is-outlined" href="https:&#x2F;&#x2F;lymslive.github.io&#x2F;blog&#x2F;download-by-wget&#x2F;">
              <span class="icon mr-2">
                <i class="fas fa-arrow-circle-left"></i>
              </span>
              linux 下载工具 wget 使用经验
            </a>
          </div>
           
          <div class="level-item has-text-centered">
            <a class="button is-black is-outlined" href="https:&#x2F;&#x2F;lymslive.github.io&#x2F;blog&#x2F;json-operator-overload&#x2F;">
              C++ 中 Json 操作符重载设计探讨<span class="icon ml-2">
                <i class="fas fa-arrow-circle-right"></i>
              </span>
            </a>
          </div>
          
        </nav>
      </div>
    </div>
  </div>
</section>



  



  
  <footer class="footer py-4">
    <div class="content has-text-centered">
      <p>
        Contact
        <a class="has-text-black" href="mailto:403708621@qq.com" target="_blank">
          <span class="icon is-large" title="Email">
            <i class="far fa-envelope fa-lg"></i>
          </span>
        </a>
        Issue
        <a class="has-text-github" href="https://github.com/lymslive/lymslive.github.io/issues" target="_blank">
          <span class="icon is-large" title="GitHub">
            <i class="fab fa-github fa-lg"></i>
          </span>
        </a>
      </p>
      <p>
        Powered by
        <span class="icon-text">
          <span class="icon">
            <i class="fas fa-power-off"></i>
          </span>
          <span>zola</span>
        </span>
        with
        <span class="icon-text">
          <span class="icon">
            <i class="fas fa-code"></i>
          </span>
          <span>code</span>
        </span>
        and
        <span class="icon-text">
          <span class="icon">
            <i class="fas fa-heart"></i>
          </span>
          <span>love</span>
        </span>
      </p>
    </div>
  </footer>
  

  
  
  
  
  <script src="https://lymslive.github.io/elasticlunr.min.js"></script>
  <script src="https://lymslive.github.io/search_index.en.js"></script><script src="https://lymslive.github.io/js/site.js"></script>

  





  
<script src="https://lymslive.github.io/js/chinese-format.js"></script>

</body>

</html>
