<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>沉思涧 - linux</title>
    <link href="https://lymslive.github.io/tags/linux/atom.xml" rel="self" type="application/atom+xml"/>
    <link href="https://lymslive.github.io"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2024-01-14T00:00:00+00:00</updated>
    <id>https://lymslive.github.io/tags/linux/atom.xml</id>
    <entry xml:lang="en">
        <title>漫谈二进制与十六进制在计算机中的运用</title>
        <published>2024-01-14T00:00:00+00:00</published>
        <updated>2024-01-14T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://lymslive.github.io/blog/hex-and-binary-digital-usage/" type="text/html"/>
        <id>https://lymslive.github.io/blog/hex-and-binary-digital-usage/</id>
        
        <content type="html">&lt;h1 id=&quot;man-tan-er-jin-zhi-yu-shi-liu-jin-zhi-zai-ji-suan-ji-zhong-de-yun-yong&quot;&gt;漫谈二进制与十六进制在计算机中的运用&lt;&#x2F;h1&gt;
&lt;p&gt;众所周知，计算机内部使用二进制，与人们日常使用的十进制大相径庭。可能有些人，包
括一些初学计算机的学生，会对此感到困惑。本文试图用浅显的语言来聊一聊这个话题。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jin-zhi-de-xuan-ze-yuan-yu-sheng-chan-shi-jian&quot;&gt;进制的选择源于生产实践&lt;&#x2F;h2&gt;
&lt;p&gt;其实，计算机是人类发明的，进制也是人类发明，所以计算机使用什么进制，只是人类的
选择。人类发明进制，主要是为了方便指导人类自身的生活及生产活动。在人类历史上，
使用最广泛的进制是十进制，大概人有十根手指，容易以此为凭计数吧。&lt;&#x2F;p&gt;
&lt;p&gt;但是，除了十进制外，人们在特定场合也经常使用其他进制。比如中国古代使用的算盘与
算筹，相当于五进制，那是在十进制为主的情况下的辅进制。现在仍然广泛使用的非十进
制是时间单位，以六十进制为主，十二进制为辅。中国古代的十天干与十二地支的循环也
是构成六十甲子循环。人类对时间的感知源于天体运动，对时间与日历的划分主要以太阳
与（或）月亮的运行规律为基础。人们不对此作十等分，而是十二等分，六十等分，是因
为发现这样更方便，更合理。譬如中国农历的二十四节气，在农业社会对农事生产的指导
是相当有意义的。所以，我们在某个领域选择某种进制，是实践导向的结果，这种进制更
适合这个领域而已。&lt;&#x2F;p&gt;
&lt;p&gt;另外，十六进也不新鲜，中国古代在称量时也用过十六进制，“半斤八两”这词就这么来的。
因为等分其实是最容易实现的，比十等分、十二等分都容易得多。不过只用一刀两半、一分
为二的粒度在很多情况下还是太粗了，所以一般要继续等分，分个三、四次，做成八等分、
十六等分，大家觉得这样的份量更方便使用，满足大部分场合的需求，就定下十六进制，
半斤八两。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ji-suan-ji-xin-xi-chan-ye-xuan-ze-liao-er-jin-zhi&quot;&gt;计算机信息产业选择了二进制&lt;&#x2F;h2&gt;
&lt;p&gt;所以，计算机使用二进制，也只是因为它更合适、更简单。首先，二进制是最小的进制，
并不存在一进制，如果一个事物只能承载一种状态，它是无法表示多种信息变化的，至少
需要两种状态，也就是二进制。其次，二进制实现也最简单。用电子元器件的高电平与低
电平就能表示 1 与 0 ，两种状态的区分与辨识是最容易的，容错也高。假设要使用所谓
的三进制，增加一种“不高不低”电平，那会使状态判断的难度剧增，完全得不偿失。这就
是大道至简，二进制足以表达任意变化，任意数据与信息，那就只用二进制就可以了。&lt;&#x2F;p&gt;
&lt;p&gt;当然，任何技术都该以人为本。在计算机之外讨论二进制的数值，经常也需要转为十进制
的“真实”数值。这种转换，只涉及一个基本的简单的数学原理。参考十进制是怎么用多项
式表示一个数的：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;1985 = 1 * 1000 + 9 * 100 + 8 * 10 + 5 * 1
&lt;&#x2F;span&gt;&lt;span&gt;     = 1 * 10^3 + 9 * 10^2 + 8 * 10^1 + 5 * 10^0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后随手写个 &lt;code&gt;1101&lt;&#x2F;code&gt; 的二进制，它就可按类似的公式求出对应的十进制表示：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;1101 = 1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0
&lt;&#x2F;span&gt;&lt;span&gt;     = 1 * 8 + 1 * 4 + 0 * 2 + 1 * 1
&lt;&#x2F;span&gt;&lt;span&gt;     = 8 + 4 + 1  = 13
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;如果要反过来，将十进制的 &lt;code&gt;13&lt;&#x2F;code&gt; 转为二进制的 &lt;code&gt;1101&lt;&#x2F;code&gt; ，那也就是个逆分解过程，不断
除 2 取余的过程，这里不再赘述。&lt;&#x2F;p&gt;
&lt;p&gt;简言之，任意进制的数值，可以用基数与进制数的指数幂多项式来表示，我们写在一起的
各位数字，在数学表达式上就是这个多项式的系数。二进制的基数只有 0 与 1 ，十进制
的基数就是常用的 0-9 这十个数，而十六进制就在 0-9 之后，借用 a-f 这六个字母分
表达到 10 至 15 的基数。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;cong-er-jin-zhi-dao-shi-liu-jin-zhi&quot;&gt;从二进制到十六进制&lt;&#x2F;h2&gt;
&lt;p&gt;除二进制外，在计算机学科还常用八进制与十六进制。但后两者不算独立的进制，它们本
质上也是二进制，或者说是基于二进制的辅进制，目的是为了更方便地表达或书写二进制
数值。&lt;&#x2F;p&gt;
&lt;p&gt;就如本文开头提及的算筹（与算盘）的五进制，它也不是独立的进制，只是十进制的辅进
制。一根算筹就像长条形的筷子，竖着放一根表示 1 ，放两根表示 2 …… 放四根表示 4
，但到了表示 5 ，它就不再是并排竖放五根了，而是横着放一根表示 5 。为啥这样规定
呢？因为一直并排着放下去，既费材料，也费空间，还对人肉识别不友好，比如并排放八
根或九根，你不能一眼很快看出具体是八根还是九根。所以就引入了“逢五转一”的辅进制，
但更根本的还是“逢十进一”的十进制。在算筹系统中，如果约定个位数用竖筹表示 1 ，
横筹表示 5 ，那么在十位数就反过来，用横筹表示 1 （也就是 10），竖筹表示 5 （也
就是 50），如此轮换，进一步增加数字的识别度。当然，这些约定，就是具体的技术与
工程问题了。现在我们不需要算筹了，所以也就不需要五进制。&lt;&#x2F;p&gt;
&lt;p&gt;但二进制仍需要八进制或十六进制的辅助，也是基于类似的表达原因。如果把写在纸上
（或打印在屏幕上）的二进制数值，那长串的 1 想象为并排竖放的算筹，就能发现问题
了，它很难被人眼识别。所以为了增加识别度，我们会将它分成三个一组，或四个一组，
并且用更丰富的数字符号（而不仅有 1 与 0）来表示每个分组部分。&lt;&#x2F;p&gt;
&lt;p&gt;其实在表达常规的十进制大数时，人们也经常会采用分组的办法。比如在西方国家，习惯
于每三位一组，有时会显式用逗号（下标）或单引号（上标）分隔，依次表示 thousand
（千）、million （百万）等。而在中国，更习惯按每四位分组，依次表示为万、亿等。&lt;&#x2F;p&gt;
&lt;p&gt;二进制的问题在于，它的单位太小，即使在日常十进制中并不大的数，用二进制表达也需
要很多位，太长了。所以对二进制位数分组，就显得更加迫切，如果每三位分组，就是八
进制，每四位分组，就是十六进制。理论上，也可以有按两位分组的四进制，与按五位分
组的三十二进制。但其他的分组二进制，并无实用，而八进制与十六进制，是有实用需求
才引入的，然后才逐渐流行起来，并成为事实标准。&lt;&#x2F;p&gt;
&lt;p&gt;八进制的基数有 &lt;code&gt;0-7&lt;&#x2F;code&gt; 八个符号，十六进制有基数有 &lt;code&gt;0-9a-f&lt;&#x2F;code&gt; 十六个符号（字母不分
大小写），它们与二进制 &lt;code&gt;0-1&lt;&#x2F;code&gt; 串组的对应关系如下：&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;基数&lt;&#x2F;th&gt;&lt;th&gt;三分组&lt;&#x2F;th&gt;&lt;th&gt;四分组&lt;&#x2F;th&gt;&lt;th&gt;十进制&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;000&lt;&#x2F;td&gt;&lt;td&gt;0000&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;001&lt;&#x2F;td&gt;&lt;td&gt;0001&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;010&lt;&#x2F;td&gt;&lt;td&gt;0010&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&lt;td&gt;011&lt;&#x2F;td&gt;&lt;td&gt;0011&lt;&#x2F;td&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;td&gt;100&lt;&#x2F;td&gt;&lt;td&gt;0100&lt;&#x2F;td&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;5&lt;&#x2F;td&gt;&lt;td&gt;101&lt;&#x2F;td&gt;&lt;td&gt;0101&lt;&#x2F;td&gt;&lt;td&gt;5&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;6&lt;&#x2F;td&gt;&lt;td&gt;110&lt;&#x2F;td&gt;&lt;td&gt;0110&lt;&#x2F;td&gt;&lt;td&gt;6&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;7&lt;&#x2F;td&gt;&lt;td&gt;111&lt;&#x2F;td&gt;&lt;td&gt;0111&lt;&#x2F;td&gt;&lt;td&gt;7&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;1000&lt;&#x2F;td&gt;&lt;td&gt;8&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;9&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;1001&lt;&#x2F;td&gt;&lt;td&gt;9&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;a&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;1010&lt;&#x2F;td&gt;&lt;td&gt;10&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;b&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;1011&lt;&#x2F;td&gt;&lt;td&gt;11&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;c&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;1100&lt;&#x2F;td&gt;&lt;td&gt;12&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;d&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;1101&lt;&#x2F;td&gt;&lt;td&gt;13&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;e&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;1110&lt;&#x2F;td&gt;&lt;td&gt;14&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;f&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;1111&lt;&#x2F;td&gt;&lt;td&gt;15&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;8进制&lt;&#x2F;td&gt;&lt;td&gt;16进制&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;在计算机相关代码或文献中，为了将八进制或十六进制与常用十进制区分开来，在表述写
法上会加点前缀。其中八进制用 &lt;code&gt;0&lt;&#x2F;code&gt; 前缀，如 &lt;code&gt;0755&lt;&#x2F;code&gt; 表示八进制的 &lt;code&gt;755&lt;&#x2F;code&gt; ，也就是二
进制的 &lt;code&gt;111 101 101&lt;&#x2F;code&gt; 。十六进制用 &lt;code&gt;0x&lt;&#x2F;code&gt; 前缀，或大写的 &lt;code&gt;0X&lt;&#x2F;code&gt; ，如 &lt;code&gt;0xfe&lt;&#x2F;code&gt; 表示十
六进制的 &lt;code&gt;fe&lt;&#x2F;code&gt; ，也就是二进制的 &lt;code&gt;1111 1110&lt;&#x2F;code&gt; ，也就是十进制数值 &lt;code&gt;254&lt;&#x2F;code&gt; 。&lt;&#x2F;p&gt;
&lt;p&gt;由此可见，八进制、十六进制与二进制的转换是非常方便的，只要按基数表查表，分别转
换即可，基本可用人肉心算。但是二进制转十进制不是恰好倍数关系，没法分组分治，转
换起来就略麻烦些。用八进制或十六进制能大辐减少二进制数的位数长度，相比十进制的
等值数值，八进制表示略长，十六进制则短得多。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ba-jin-zhi-de-ying-yong-chang-jing&quot;&gt;八进制的应用场景&lt;&#x2F;h2&gt;
&lt;p&gt;据说，早期计算机的一个字节，不都是八位，而也有六位的情况。这可能是由于相关元器
件制造工艺与成本的原因，做六根导线比八根线会相对容易些吧。但现今这不是问题了，
一个字节八比特位已是工业与学界标准。八比特位正好分成两个四位组，也就是两个十六
进制数字，所以使用十六进制非常方便。但如果一个字节是六比特位的情况，则用八进制
更方便，这可能就是八进制出现的一个原因。&lt;&#x2F;p&gt;
&lt;p&gt;而现在，八进制与字节没关系了，所以它的应用场景远不如十六进制。现在仍然在广泛使
用的场合是 linux&#x2F;unix 系统的文件权限表示位。&lt;&#x2F;p&gt;
&lt;p&gt;文件有三个重要权限，分别是读、写与执行。是否可读或写好理解，是否可执行是表示该
文件是否能像程序那样执行，否则就当作普通的数据文件。在 Linux 中，很多普通文本
文件都可能是可执行的脚本程序，所以可执行这个属性或权限很重要。这三种权限，通常
表示为 &lt;code&gt;rwx&lt;&#x2F;code&gt; ，分别只有两种状态，是否或有没有该种权限，那就可用 &lt;code&gt;0&lt;&#x2F;code&gt; 或 &lt;code&gt;1&lt;&#x2F;code&gt; 表
示，即三位二进制数，也就可用一位八进制数来表示。在 Linux 中，相对于文件的用户
又分为三种，即文件所有者（owner）、同组用户（group）与其他用户（other），每种
用户的权限用一位八进制的话，完整权限就是三位八进制数字表示了。&lt;&#x2F;p&gt;
&lt;p&gt;Linux 用 &lt;code&gt;chmod&lt;&#x2F;code&gt; 命令来修改权限，它接受八进制数值，也接收文本参数，用文本参数
可能更直观，但当熟悉八进制表示法后，用八进制更简捷与直接。假设现在有个文件
&lt;code&gt;file.txt&lt;&#x2F;code&gt; 的权限是 &lt;code&gt;400&lt;&#x2F;code&gt; ，表示只有该文件的所有者有读权限，其他用户没有任何权
限；根据系统用户合作需要，要使其他用户也有读权限，自己及其他同组用户有写权限。
若用文本参数描叙这些权限修改动作，可能要分几条命令来执行：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;chmod&lt;&#x2F;span&gt;&lt;span&gt; +r file.txt
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;chmod&lt;&#x2F;span&gt;&lt;span&gt; u+w file.txt
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;chmod&lt;&#x2F;span&gt;&lt;span&gt; g+w file.txt
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;最终结果的权限是 &lt;code&gt;-rw-rw-r--&lt;&#x2F;code&gt; ，转为二进制是 &lt;code&gt;110 110 100&lt;&#x2F;code&gt; ，转成八进制就是
&lt;code&gt;664&lt;&#x2F;code&gt; ，所以直接按八进制数值修改权限的操作会更快：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;chmod&lt;&#x2F;span&gt;&lt;span&gt; 664 file.txt
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当然，另外有个常见需求，写完一个脚本后，需要给它加个可执行权限，如果想给所有用
户加个可执行权限，用文件参数 &lt;code&gt;+x&lt;&#x2F;code&gt; 更方便：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;chmod&lt;&#x2F;span&gt;&lt;span&gt; +x script.sh
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;但如果觉得给其他用户开脚本运行权限是比较危险的事，只想给自己及或信任的同组用户
开执行权限，那就用八进制一次修改更方便了，如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;chmod&lt;&#x2F;span&gt;&lt;span&gt; 774 script.sh
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;除了 Linux 文件权限表示法，笔者并没有在其他方面看到八进制有良好的运用实践了。
可以想见，如果 Linux&#x2F;Unix 系统完成历史使命，或者有更好的方式来表达权限特征，八
进制或许也会像五进制那样退出历史舞台。在八位字节统一标准后，只要十六进制辅助二
进制就足够了，没必要增加更多的复杂性。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shi-liu-jin-zhi-wei-biao-de-er-jin-zhi&quot;&gt;十六进制为表的二进制&lt;&#x2F;h2&gt;
&lt;p&gt;因此，现在在很多场合下，十六进制与二进制，几乎是同义词了。二进制为里，十六进制
为表，在内部用二进制运算，输出给人类用户看时用十六进制。&lt;&#x2F;p&gt;
&lt;p&gt;比如，很多宣称能编辑二进制的文本编辑器，它实际是展示十六进制的。Linux 下常用的
文本编辑器 vim 也有二进制编辑功能，执行 &lt;code&gt;:%!xxd&lt;&#x2F;code&gt; 就把当前文件转为二进制“打开”
了。实际上 &lt;code&gt;xxd&lt;&#x2F;code&gt; 是随 vim 安装的独立工具，其功能是将输入内容用十六进制方式打印
出来。而在 vim 中执行 &lt;code&gt;:%!xxd&lt;&#x2F;code&gt; 其实是利用了 &lt;code&gt;:!&lt;&#x2F;code&gt; 的过滤功能，调用外部 &lt;code&gt;xxd&lt;&#x2F;code&gt; 程
序将当前编辑内容转为十六进制展示，并替换当前编辑内容（注意不要用 &lt;code&gt;:w&lt;&#x2F;code&gt; 保存，
否则就将十六进制的展示方式当作实际内容写入文件了，这很可能不是想要的；看完十六
进制的展示，最好用 &lt;code&gt;u&lt;&#x2F;code&gt; 命令撤回操作，回到正常文本展示模式）。&lt;&#x2F;p&gt;
&lt;p&gt;所以我们也可直接在 shell 命令行中用 &lt;code&gt;xxd&lt;&#x2F;code&gt; 来查看文件的二进制内容，例如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;xxd ~&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;.bashrc
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;00000000:&lt;&#x2F;span&gt;&lt;span&gt; 2320 7e2f 2e62 6173 6872 633a 2065 7865  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# ~&#x2F;.bashrc: exe
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;00000010:&lt;&#x2F;span&gt;&lt;span&gt; 6375 7465 6420 6279 2062 6173 6828 3129  cuted by bash(1)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;00000020:&lt;&#x2F;span&gt;&lt;span&gt; 2066 6f72 206e 6f6e 2d6c 6f67 696e 2073   for non-login s
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;00000030:&lt;&#x2F;span&gt;&lt;span&gt; 6865 6c6c 732e 0a23 2073 6565 202f 7573  hells..# see &#x2F;us
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;00000040:&lt;&#x2F;span&gt;&lt;span&gt; 722f 7368 6172 652f 646f 632f 6261 7368  r&#x2F;share&#x2F;doc&#x2F;bash
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;00000050:&lt;&#x2F;span&gt;&lt;span&gt; 2f65 7861 6d70 6c65 732f 7374 6172 7475  &#x2F;examples&#x2F;startu
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;00000060:&lt;&#x2F;span&gt;&lt;span&gt; 702d 6669 6c65 7320 2869 6e20 7468 6520  p-files (in the
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;00000070:&lt;&#x2F;span&gt;&lt;span&gt; 7061 636b 6167 6520 6261 7368 2d64 6f63  package bash-doc
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;00000080:&lt;&#x2F;span&gt;&lt;span&gt; 290a 2320 666f 7220 6578 616d 706c 6573  )&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;.#&lt;&#x2F;span&gt;&lt;span&gt; for examples
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;00000090:&lt;&#x2F;span&gt;&lt;span&gt; 0a0a 2320 4966 206e 6f74 2072 756e 6e69  ..# If not runni
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;000000a0:&lt;&#x2F;span&gt;&lt;span&gt; 6e67 2069 6e74 6572 6163 7469 7665 6c79  ng interactively
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;000000b0:&lt;&#x2F;span&gt;&lt;span&gt; 2c20 646f 6e27 7420 646f 2061 6e79 7468  , don&amp;#39;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;t do anyth
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;000000c0: 696e 670a 6361 7365 2024 2d20 696e 0a20  ing.case $- in.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;000000d0: 2020 202a 692a 2920 3b3b 0a20 2020 2020     *i*) ;;.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;......
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;而 &lt;code&gt;.bashrc&lt;&#x2F;code&gt; 其实是个普通文本文件，对应的前面几行如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cat ~&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;.bashrc
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# ~&#x2F;.bashrc: executed by bash(1) for non-login shells.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# see &#x2F;usr&#x2F;share&#x2F;doc&#x2F;bash&#x2F;examples&#x2F;startup-files (in the package bash-doc)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# for examples
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;# If not running interactively, don&amp;#39;t do anything
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;case &lt;&#x2F;span&gt;&lt;span&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;in
&lt;&#x2F;span&gt;&lt;span&gt;    *i*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;) &lt;&#x2F;span&gt;&lt;span&gt;;;
&lt;&#x2F;span&gt;&lt;span&gt;......
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;大家可以对照着文件的实际内存，体会一下 &lt;code&gt;xxd&lt;&#x2F;code&gt; 打印二进制文件的格式，其他二进制
编辑器也基本是类似的风格。前面的“行号”，其实是地址，第二行 &lt;code&gt;10&lt;&#x2F;code&gt; 的十六进制数值
等于十进制的 &lt;code&gt;16&lt;&#x2F;code&gt; ，也就是每行打印 16 个字符（或字节）。中间部分的主体内容就是
每个字节的十六进制表示，每两个数值代表一字节，每两个字节间它额外加个空格也只为
整齐分隔，否则 32 个数字连在一起辨别困难。右侧部分是对应该行每个字节的文本展示，
如果是可打印字符（32-126 ascii 码），就可直接打印，其他字符统一用点占位表示不
可打印，比如该文件实际内容的第一行末尾的换行符 &lt;code&gt;0a&lt;&#x2F;code&gt; ，就大约在第 &lt;code&gt;30&lt;&#x2F;code&gt; 行中间位置。
另外注意，空格（十六进制 &lt;code&gt;20&lt;&#x2F;code&gt;）是也算可打印字符，右侧也对应一个空格。对于真正
的二进制文件，非文本文件，&lt;code&gt;xxd&lt;&#x2F;code&gt; 输出的右半侧预览基本都是一些不可识别的 &lt;code&gt;.&lt;&#x2F;code&gt; ，
即使偶尔碰巧是可打印字符，也未必是原文件的本意，只是某个字节正好落在 &lt;code&gt;[32, 126)&lt;&#x2F;code&gt; 
区间。&lt;&#x2F;p&gt;
&lt;p&gt;再举个常见的例子，MD5 摘要，它将任意长度的数据，通过某种算法得到 16 字节摘要。
Linux 下也有个命令 &lt;code&gt;md5sum&lt;&#x2F;code&gt; 用于求一个文件的 MD5 摘要，它打印的是 32 个数字，
用以表达内部算法求出的 16 个字节数据。如：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;md5sum&lt;&#x2F;span&gt;&lt;span&gt; .bashrc
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;f45e5e883584d4a9f955562066cf75f3&lt;&#x2F;span&gt;&lt;span&gt;  .bashrc
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;er-jin-zhi-da-shu-de-shi-jin-zhi-dan-wei&quot;&gt;二进制大数的十进制单位&lt;&#x2F;h2&gt;
&lt;p&gt;如前所述，在计算机很多领域，二进制或十六进制是表示数据的，并不一定有数值意义。
在向人类传达数据信息时，用两个十六进制数字代替一个字节数据更方便。此外，将十六
进制当作数值时，一般只用在与内存、存储相关的地址或容量上。&lt;&#x2F;p&gt;
&lt;p&gt;在表示容量数值时，人们又更习惯于十进制的表达，于此又衍生出一系列容量单位，如：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;1K = 1024 = 2^10&lt;&#x2F;li&gt;
&lt;li&gt;1M = 1024K = 2^20&lt;&#x2F;li&gt;
&lt;li&gt;1G = 1024M = 2^30&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;这种 1024 的“进制”单位，主要是用于表达字节数量，写作 &lt;code&gt;KB&lt;&#x2F;code&gt; 或 &lt;code&gt;MB&lt;&#x2F;code&gt; ，而不会单独
使用 &lt;code&gt;K&lt;&#x2F;code&gt; 来表示 1024，比如我们不会将某件商品卖价 1024 元写作 1K 元，不合习惯而
已。同时，这些单位是给十进制数值体系用的，比如我们会说 &lt;code&gt;15G&lt;&#x2F;code&gt; ，而不会说（十六
进制）&lt;code&gt;fG&lt;&#x2F;code&gt; 。&lt;&#x2F;p&gt;
&lt;p&gt;事实上，单独的 &lt;code&gt;K&lt;&#x2F;code&gt; 在十进制中也经常表示 1000 。所以一些硬盘生产商就会故意混淆
概念，标称 1GB 的容量，其实没有 1024MB ，只有 1000MB 。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jie-yu&quot;&gt;结语&lt;&#x2F;h2&gt;
&lt;p&gt;本文简单探讨了计算机领域使用二进制与十六进制的相关话题。这尤其说是一种技术，不
如说是一种文化习惯，毕竟进制这概念在数学原理上也不复杂。在当前信息时代，即使不
是计算机从业人员，了解基本的二进制与十六进制也是有益的，以增加对这种数值表达的
熟悉与敏感度。&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>make 不干编译事的清奇妙用：子命令模式脚本</title>
        <published>2023-12-26T00:00:00+00:00</published>
        <updated>2023-12-26T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://lymslive.github.io/blog/make-as-sub-command/" type="text/html"/>
        <id>https://lymslive.github.io/blog/make-as-sub-command/</id>
        
        <summary type="html">&lt;h2 id=&quot;yin-yan&quot;&gt;引言&lt;&#x2F;h2&gt;
&lt;p&gt;说起 make ，大家的印象想必都是 Linux 下用于编译构建 C&#x2F;C++ 项目的原始工具。后来
随着 cmake 及其他多种构建工具的发展与流行，手搓 makefile 的情况应该越来越少
了。而且除了 cmake ，有些构建工具是根本不必生成 makefile 就直接自己处理依赖编
译项目了，这比借助 makefile 路径依赖还更高效些。于是 make 在构建系统的作用与地
位就逐渐淡出了。&lt;&#x2F;p&gt;
&lt;p&gt;不过再追溯一下 make 本源，它似乎并不是专为编译构建而诞生的。早期 Linux 的许多
经典工具都只有简单到令人吃惊的小功能，贯彻着“一个程序只做好一件事”的哲学思想。
所以 make 的核心功能也非常简单，就只是检测目标与依赖（文件）的关系，当依赖有更
新时，执行相应的命令让目标也得以更新。而这个功能，明面上完全看不出来它与用 gcc
编译 C&#x2F;C++ 项目有什么必然联系。只过在 Linux 上工作的程序员先驱们，竟然能在这么
简单的 make 基础上，发展出完备而复杂的构建系统，也是令我们后学惊叹的。&lt;&#x2F;p&gt;
&lt;p&gt;所以我有时在想，在如今不一定需要用 make 来构建 C&#x2F;C++ 项目的时代，利用 make 的
核心功能与思想，还能否玩出其他有趣的花样？本文就介绍笔者在实际工作中遇到的一个
常用场景，利用 make 来组织一堆简单小脚本，提供统一命令行用法，让 make 命令华丽
转身，活像个能带自定义子命令的命令行工具。而子命令模式，正是当前流行的命令行工
作方式，像 git docker systemctl 等强大的流行工具就是子命令模式。&lt;&#x2F;p&gt;
</summary>
        
    </entry>
    <entry xml:lang="en">
        <title>探索 systemd 管理服务之旅</title>
        <published>2023-11-21T00:00:00+00:00</published>
        <updated>2023-11-21T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://lymslive.github.io/blog/systemd-service-practice/" type="text/html"/>
        <id>https://lymslive.github.io/blog/systemd-service-practice/</id>
        
        <summary type="html">&lt;!-- # 探索 systemd 管理服务之旅 --&gt;
&lt;p&gt;最近学习了用 systemd 管理服务，感觉挺有趣。故有意写下自己的心路历程与人分享。
systemd 是 linux 下的系统管理工具，功能强大，其实远不限于管理服务，不过本文暂
且先只讨论服务。&lt;&#x2F;p&gt;
</summary>
        
    </entry>
    <entry xml:lang="en">
        <title>浅谈 GNU Make 构建项目实践</title>
        <published>2019-07-06T00:00:00+00:00</published>
        <updated>2019-07-06T00:00:00+00:00</updated>
        <author>
          <name>Unknown</name>
        </author>
        <link rel="alternate" href="https://lymslive.github.io/blog/make-practice/" type="text/html"/>
        <id>https://lymslive.github.io/blog/make-practice/</id>
        
        <summary type="html">&lt;!-- # 浅谈 GNU Make 构建项目实践 --&gt;
&lt;h2 id=&quot;zhai-yao&quot;&gt;摘要&lt;&#x2F;h2&gt;
&lt;p&gt;本文简明地介绍 &lt;code&gt;make&lt;&#x2F;code&gt; 的基础原理，并组合实际项目经验，由浅入深讨论了一种实用
的 &lt;code&gt;makefile&lt;&#x2F;code&gt; 通用规则与模板的编写方案。对其中涉及的语法功能技巧择要阐述，希望
有助于初学者理解。&lt;&#x2F;p&gt;
</summary>
        
    </entry>
</feed>
