+++
title = "深入理解 rapidjson 与实践"
draft = true
[taxonomies]
categories = ["程序设计"]
tags = ["C++", "json","工具库"]
[extra]
toc = true
+++

众所周知，JSON 是通用对象表示法。原全称是 JavaScript Object Notation ，是从
javascript 语言流行开来的。json 在 javascript 源码中就是合法的对象字面量表示，
可认为是后者的一个子集，语法更严格，但也更简单，基本可望文生义。后来也有人提出
json5 的扩展语法，能支持注释等，更接近 javascript 的语法（但仍不完全一样），但
也不如标准 json 那样流行，简单够用。

如今，几乎所有流行与不流行的编程语言都支持 json ，能将 json 文本串解析为各自语
言内部的对象模型表示。这是通过库来实现的，不能像 javascript 那样直接将 json 粘
贴到源代码中就是合法对象（一般可用在 `=` 作右值常量），虽然有的语言可能有语法
糖能在源代码中通过对 json 串作少量的修饰而转化为内部对象，但本质上也是经过了库
解析。而事实上，对于大对象，长 json 串，即使 javascript 也不会直接嵌在源代码中，
而是先从外部读入字符串，再通过 `JSON` 库将其解析为对象。

Json 的文本表示即字符串，也叫对象的序列化，而将 json 文本转为语言内部对象的工
作叫反序列化。各大语言的 json 库的基本功能或主要功能就是这两个方面。本文将讨论
的 C++ ，更是有许多不同的 json 库。笔者使用最多的是 rapidjson 库，这是个老牌的
经典 json 库，在 modern C++11 之前就存在的高性能 json 库，至今也在一众 C++ 
常见 json 库的前一档。所以笔者强烈推荐这个 C++ 开源库，它是 head-only 库，只要
下载头文件，很容易集成进自己项目试水。
<!-- more -->

## 细说 Json 的值类型

### 六大类型的标量与集合

标准 json 就六种类型：

1. Number 数字类型，不分整数或浮点数，在原生 javasrcipt 中用 `double` 表示；
2. String 字符串类型，也叫文本类型，严格地说要符合 `utf-8` 编码的字节串；
3. Array 数组类型，有序包含多个其他类型；
4. Object 对象类型，用键值对包含多个其他类型，其中键只能是字符串；
5. Boolean 表示只有两种状态的布尔类型，也就只有两个值 `true` 或 `false`；
6. Null 表示值空缺的状态，就一个值 `null` 。

一个简单的 json 示例如下：

```json
{
  "number": 123,
  "string": "hello world",
  "array": [1, 2, 3.14, "string"],
  "object": {
    "key": "value",
    "no-value": null,
    "bool-value": true
  }
}
```

再仔细审视 json 这六种值类型，这是从底层表示或实现划分的，如果从应用逻辑的抽象
角度再去考虑，又主要可以分为两大类，或三类：

1. 标量，表示一个值，用数字或字符串表达一个意义；
2. 集合，数组代表有序集合，对象代表无序集合，因其无序，所以要用键名取值；
3. 特殊标记值，就是 `true` `false` 与 `null` 这三个。

最后一类，从某种意义上看也可算是标量，但事实上即使没有这类的三个特殊值，也能满
足实际的应用需求。所以，从实用角度讲，标量就认为只是数字或字符串，这算是在计算
机信息处理的基本分子，而分子的有机组合，就构成了功能实体，类似物理学科所讲的物
质或生物学所讲的细胞组织。所以，json 就能用这个简单的模型来表示现实世界的逻辑
抽象模型，而它是语言中立的，各个语言都能很容易将这个模型映射到自己语言特有的类
型或对象系统中。

### 忽视 josn 类型的误区

一个常见的误区是，把 json 等效为对象，或认为 json 的根只能是对象，就是一对大括
号 `{}` 包裹一些键值对。虽然大多用 json 交换数据的数应用系统确实长这样，但并不
代表这是唯一合法的 json 。以数组 `[]` 为根的数据也是常见且实用，主要是表达对象
数组的含义。此外，即使简单的一个数字或（双引号包含的）字符串，它们也是合法的
json ，虽然这不常见，但也应该考虑这种特殊情况是否会引起异常。当然了，那些不是
以对象为根的 json ，也容易转为以对象为根的 json ，不外是多包一层 `{}` ，将原
json 当成它的唯一值，再取个好听恰义的键名。

另一个误区或不良实践，是标量只用字符串表示，数字也加上了引号，这在前端通过表单
输入构成的 json 就容易变成这样子。json 是有类型的，数字与文本两大类型还是应该
根据 json 标准来区分的，这不仅是逻辑上的意义不同，很多强类型语言在 json 实现中
对数字与字符串也是需要不同处理的。如果说字符串理论上可以表达一切，确实如此，字
符串也能表达数组与对象，试看下面的例子：

```json
{
  "number": "123",
  "array": "[1,2,3]",
  "object": "{\"key\":\"value\"}"
}
```

显然，这段 json 数组想表达的真实意图是：

```json
{
  "number": 123,
  "array": [1,2,3],
  "object": {"key":"value"}
}
```

对于数组与对象，很少有人会这么滥用字符串，毕竟知道难看，而用字符串表达数值类型
与这本质上是同样的错误。如果系统设计只支持一层对象结构，那么将个别的子对象序列
化的文本存为字符串还算有妥协意义。但用字符串表示数字，那基本就是偷懒意义了。

不过也有个例外，json 能表示的数值精度有限，可能无法表达大整数，比如长 id 。尤
其是原生 javascript 及其他很多弱类型语言，用 8 字节的 `double` 表示数字，那就
不能安全地表达 64 位整数，而很多系统会用 64 位整数作 id 。然而从应用逻辑看，id
算是文本意义，因为常规数字支持的四则运算对 id 是没有意义，对 id 最主要的操作是
比较用于查找（自增也有意义，但非必要，且字符串定义自增操作也是有意义）。所以
id 在系统之间适合用字符串传递，而各系统在接收后也完全可以把它当作字符串处理，
只有在意计算与存储性能时才会把它转为整数来处理。

除此之外，在应用逻辑上该是整数的数据，尤其是上限不超常用的 32 位整数时（用
`double` 能安全表达的整数上限其实比 32 位整数大，但比 64 位整数小），就该坚持
用 json 的数字类型，不要加双引号，这对传输与解析效率都是有利的。此外，在需要对
json 瘦身的场合，可以考虑用更简短（但仍要有可读意义）的键名，以及善用数组代替
对象，减少键名的使用。

标准 Json 的数字类型只支持十进制表示法，不区分整数或小数（浮点数）。但严肃项目
中，尽量避免浮点数吧，因为浮点数计算精度有累积误差问题，不同语言不同库对浮点数
的序列化与反序列化甚至也会有偏差。因此，规定浮点数精度或小数数位格式化改用字符
串传递也可能是合理的。但如果能约定小数位数的精度，那为何不直接扩大这么多倍数改
用整数交互呢？

此外，如果系统不涉及无理数，但要求精确的有理小数，可以用考虑只包含两个元素的数
组（分别表示分子与分母）来表示小数。什么，你的系统居然要处理复数？那么用一个对
象的两个键分别表示实部与虚部即可解决。

在具体的系统或项目中，json 的布尔类型可能是不必要的，用数字 `0` 与 `1` 就可以
分别代替 `false` 与 `true` 的意义，并且增加传输效率。不过一些强类型语言的库可
能会严格区分整数与布尔类型，为了好好协作，作也同样的严格区分也是符合标准。不过
决定一个值使用布尔类型前要谨慎确定需求，别搞出后面改需求说不止两个状态的尴尬。

至于 `null` ，我是反对在序列化传输中出现 `null` ，没有值的字段就不传嘛，没必要
多此一举传 `null` 还增加传输流量。我相信在绝大部分系统开发中，都不会对“不传”与
传 `null` 作不同的解释而进入不同的代码分支，所以传 `null` 只不过增加错误或异常
处理的难度与麻烦。`null` 应该只限定于系统内部运算时出现的特殊状态标记，但序列
化后应该剔除对象中值为 `null` 的键。在数组中，`null` 也许能起到占位的作用，不
能武断删除，比如短数组约定不同位置有不同意义，但均质意义的长数组剔除 `null` 是
安全的。数组中连续的逗号，不符合标准 json 语法，但或许有的 json 库能容许解析出
`null` ，确有此需求时，应统一写上 `null` 。

## Json 类型在 C++ 的表示

根据 json 的数据表达模型，考虑在 C++ 中该如何表示呢？我们先做个直观与初步的联
想，再参看 rapidjson 的实现。

### C++ 的 json 概念类型

C++ 是强类型语言，每种类型都代表着一种内存模型，即根据类型来解释一段内存区域的
字节表示什么意义。而 json ，如上所述，是多种类型的混合。在 C++ 中有什么类型可
以一对多映射到 json 的各种类型呢？还真有，C 语言就有的 `union` ，叫联合，就是
一段内存可以用不的类型来解释，当然在任一时刻应该只当其中一种类型去用。

先看 json 数字类型，这在 C++ 中要细分为整数与浮点数，整数又有几种不同字节大小
的整数类型，而浮点数又分单精度与双精度。当然在实践中，四字节整数即 `int` 是最
常用的，32 位的整数不够用就用 64 位整数，而双精度浮点数也是八字节，所以定义一
个八字节的联合数字类型应该是比较恰当的，能满足大部分需求。示例定义如下：

```c++
union Number {
  int i;
  uint32_t u;
  int64_t l;
  uint64_t ul;
  double d;
  float f;
};
```

字符串比较复杂，我们先简单假设它就存一个 `std::string` 指针，也只有指针能放在
`union` 中，类尤其是有构造函数的非平凡类，是不能当作联合成员的。当把数字与字符
串联合在一起时，就构造了 json 的基础标量：

```c++
union Scalar {
  union Number num_;
  string* str;
}
```

再看 json 的集合类型，显然它应该用个容器来表示，容器元素就是 json 类型。既然有
两种集合类型，那也就联合两种常用容器的的指针来表示吧：

```c++
union Polymer {
  vector<json_t>* array;
  map<string, json_t>* object;
};
```

再把 json 的标量与集合类型联合起来，顺便捎上不关键的 `bool` 与 `null` ，那就构
成了 json 的联合类型。但是等等，我们还需要一个变量来指示 json 的联合类型当前是
哪个类型，显然这个指示变量适合用枚举表示。所以，最终的 json 类型应该是一个
`union` 与 `enum` 的结合体（也就相当于 rust 语言的 `enum` 含义）。大致示例如：

```c++
// json-concept.cpp
struct json_t {
  union JsonValue {
    union Scalar {
      union Number {
        int i;
        uint32_t u;
        int64_t l;
        uint64_t ul;
        double d;
        float f;
      } num_;
      bool b;
      string* str;
    } scaler_;
    union Polymer {
      vector<json_t>* array;
      map<string, json_t>* object;
    } polymer_;
    void* null_;
  } value_;

  enum JsonType {
    JSON_NUMBER, JSON_STRING,
    JSON_ARRAY, JSON_OBJECT,
    JSON_BOOL, JSON_NULL,
  } type_;
};
```

这只是一个粗略的 json 概念模型。事实上，联合并没有必要嵌套，json 类型 `json_t`
就是由 `JsonValue` 联合与 `JsonType` 枚举的组成结构体。上面写成嵌套的联合，只
是想表达 json 的标量与集合，数字与字符串的不同与层次。此外注意，`JsonType` 是
按 json 的六大类型来枚举的，而这在 C++ 中是不够的，因为数字类型还得细分好几类
呢，但在这个简化的概念模型中就不枚举太细了。

再分析一下，上面的 json 概念类型有多大，即 `sizeof(json_t)` 的大小。在
`JsonValue` 的联合体中，最大的成员是 64 位整数，各种指针也是 64 位（按现在最常
用的 64 位机器而论），所以是 8 字节。`JsonType` 最多一字节可表示，但由于位对齐
的原因，它也要补齐 8 字节。因此这个 `json_t` 的大小是 16 字节。

### rapidjson 的值内存模型

在 rapidjson 库，核心是 `rapidjson::Value` 类型，其实它是一个模板类的特化，不
过本文以及日常使用都几乎不必在意它底层的模板细节。`rapidjson::Value` 也只有 16
字节大小，但具体实现上显然要比上面介绍的 json 概念类型精妙许多。

对于 json 的数字类型，与上节概念模型的 `union Number` 差不多，不过删去了
`float` 。因为在能使用双精度浮点数的情况下，实没必要支持单精度，在联合体内也省
不了内存。但按习惯，四字节的整数 `int` 还是要单独支持的，不好只用八字节的长整
数。比 `int` 小的整数如 `char` 与 `short`  ，在运算时其实也会自动提升到 `int`
类型。所以只要支持四字节与八字节两类整数，及其无符号的变体。

而对 json 字符串的实现，就大有讲究了，在 `rapidjson::Value` 的内存模型上是最复
杂的一类了。具体讲，它又细分为三类字符串：

1. 短字符串，长度 13 字节以下直接存在分配给变量本身的栈区空间；
2. 借用字符串，只存字符串的指针，但不拥有字符串的所有权；
3. 复制字符串，也存个指针，拥有所有权，复制到堆空间。

既然 `rapidjson::Value` 的联合内存段有 16 字节大小，为什么只能存最长 13 字节的
短字符串呢？除去末尾需要 `\0` 对字符串封端，应该还有 15 字节呀。答案是它还要预
留末尾两个字节用于表示当前类型，就如上节的 `JsonType` 字段，不过在它源码中叫
`flag` 。

在短字符串模式下，除去 `flag` 尾字节，第 14 字节存的是短字符串剩余空间。如果只
存了一个字符，那它存在第 1 字节 `[0]` ，第 14 字节存 12 ，中间字节都是 `0` ；
如果填满了 13 字节，那第 14 字节填 `0` ，既表示剩余空间为 `0` ，也表示空字符
`\0` 结束字符串。如此字符串的长度也可以通过第 14 字节的值计算得出，不必额外存
个字段表示长度。

但在表示后面两种字符串时，除了指针，还要一个长度字段。它们在内存布局上是几乎相
同的，只有最后两字节的 `flag` 含不同的值，标记着自身是否对指针所针的字符串拥有
所有权。你可能会想，一个指针 8 字节可以放前面，后 8 字节除去末尾标记字节，还有
6 字节，可以存一个 `int` 表示长度，只浪费 2 字节。

然而真实图景不是这样，`rapidjson::Value` 将指针放在了后 8 字节，与末 2 字节的
标记字段有重叠！这就涉及 rapidjson 库的一个重要优化了，叫 48 位指针优化。因为
在当前的 64 位机器架构中，虽然指针理论上要占 8 字节，但实际上用不到 8 字节，6
字节 48 位就足够表示现实机器支持的内存空间了。想当初在 32 位机器的时代，最多支
持 4G 的内存，早就不够用了。但 64 位，2 的 64 次方是个很大的数了，能表示的最大
内存已经超过现实机器能装的内存条了。所以 48 位指针也够了。

在 `rapidjson::Value` 中，可以认为后 8 字节指针与末 2 字节标记使用如下联合共享
内存：

```c++
union pointer_64t
{
  char* pointer;
  struct {
    char padding[6];
    char flag[2];
  } byte_8t;
};
```

但是由于内存的部分重叠，读写指针时不能直接操作 `pointer` 成员，因为它会影响至
关重要的 `flag` 。所以在 rapidjson  库中专门封装了相应的函数及宏，通过位移的手
段来操作指针，达到只影响 `padding` 那 6 字节而不影响 `flag` 的目的。

于是，`rapidjson::Value` 对三类字符串的联合定义大概如下：

```c++
typedef char pointer_48t[6];
union JsonString
{
  struct ShortString {
    char buffer[14];
    char flag[2];
  } str1;

  struct BorrowString {
    int length;
    int hashCode; // 保留字节
    pointer_48t ptr;
    char flag[2];
  } str2;

  struct OwnerString {
    int length;
    int hashCode; // 保留字节
    pointer_48t ptr;
    char flag[2];
  } str3;
};
```

当然在 rapidjson 源码中，并没有显式定义 `pointer_48t` ，本文只为阐释其设计思想
作这样的表述。事实中，它在作 48 位指针优化是有条件编译宏控制的，如果所在机器必
须用到 64 位来表示指针，那它就不能作此优化假设，必须将 `flag` 定义成独立字段，
然后 `rapidjson::Value` 的大小就不是 16 字节了，而是 24 字节。但是在笔者工作过
的机器环境中测试过，都是 16 字节。

再看第 2 类与第 3 类的指针字符串，如前所述，其内存布局一样。保存 `length` 信息
字段是为了避免每次用 `strlen` 求长度。借用字符串，最常见的是自己写在源代码的字
符串字面量，因其存在进程的文本区，拥有静态生命周期，借用是安全的，所以能隐式转
为借用（引用）直接赋值给 `rapidjson::Value` 变量，没有其他开销。但其他字符串变
量，需要显式转为借用，且要自己保证指针安全，一般不建议找这麻烦。

第 2 类借用字符串显然是只读的，第 3 类复制了副本的字符串也是设计为只读的，所以
它只存了长度信息，而没有存容量信息。即当一个字符串复制进 `rapidjson::Value` 后，
它就不可再变了，不能像 `std::string` 那样可在后面追加字符。不可变的字符串，才
更切合标量的逻辑意义，虽然它是由多个字符组成，但是整体当作一个意义。

当理解 `rapidjson::Value` 如何用指针表达字符串类型后，对于数组与对象类型的表示
也就直观了。把数组与对象当作容器，除了指针、长度信息外，还有个容量字段，以便支
持往容器增删元素，容器内元素是另外一些 `rapijson::Value` 。大致结构形如：

```c++
struct JsonArray {
  int size;
  int capacity;
  pointer_48t array; // rapidjson::Value*
  flag[2];
};

struct JsonObject {
  int size;
  int capacity;
  pointer_48t object; // rapidjson::Value[2]*
  flag[2];
};
```

在这里，`rapidjson::Value` 实现数组与对象又呈现高度一致性，指针指向的堆区是另
一段连续的 `rapidjson::Value` 元素。只不过对象所指连续区域，保证是两两一组，第
一个是键名，第二个是值，键与值也都是 `rapidjson::Value` 类型，只是对键再作了一
层限制，只能是字符串类型。它们的初始容量都是 16 ，对数组而言，就是申请 `16*16`
字节，对对象而言，则申请 `32*16` 字节大小的内层。

所以在 rapidjson 中，对象也是有序的，能保持读入 json 串原来的键顺序，甚至允许
重名键。这是由它的实现方式决定的，也是与其他 json 库的一个显著不同点。

把以上数字、字符串、数组与对象类型的结构表示联合起来，就是 `rapidjson::Value`
完整的内存表示。`null` 与布尔类型都在末位 `flag` 表示，布尔类型被拆成 `true`
与 `false` 两种，与 `null` 相似的特殊类型标记，所以六大类型变成七大类型，枚举
如下：

```c++
enum rapidjson::Type {
    kNullType = 0,      //!< null
    kFalseType = 1,     //!< false
    kTrueType = 2,      //!< true
    kObjectType = 3,    //!< object
    kArrayType = 4,     //!< array 
    kStringType = 5,    //!< string
    kNumberType = 6     //!< number
};
```

但是只有这几个大类还不够，因为数字与字符串类型还有几种小类，所以在
`rapidjson::Value` 类内又定义了如下枚举：

```c++
enum {
    kBoolFlag       = 0x0008, // 布尔类型
    kNumberFlag     = 0x0010, // 数字类型
    kIntFlag        = 0x0020, // 整数
    kUintFlag       = 0x0040, // 无符号整数
    kInt64Flag      = 0x0080, // 长整数
    kUint64Flag     = 0x0100, // 无符号长整数
    kDoubleFlag     = 0x0200, // 浮点数
    kStringFlag     = 0x0400, // 字符串类型
    kCopyFlag       = 0x0800, // 复制字符串
    kInlineStrFlag  = 0x1000, // 内联短字符串
};
```

平心而论，这两个枚举有一定的重叠与冗余。`Type` 枚举反映了对标准 json 数据类型
的建模，`Flag` 枚举则是按 `rapidjson::Value` 实现定义的。不管如何，这些枚举常
量，都可以压缩放在末尾两字节的 `flag` 字段中。`Type` 七大类的递增值，用 3 位
可以表示，剩下的每个 `Flag` 占 1 位，还没用完两字节的 16 位。

末尾 `flag` 的 16 位标记图示如下：

![flag 图示](./rapidjson-flag.png)

Json 主要类型在 `rapidjson::Value` 的内存模型图示：

![type 图示](./rapidjson-type.png)

### rapidjson 的内存池模型

## rapidjson 的使用 api
